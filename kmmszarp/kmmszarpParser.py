# Generated from ./kmmszarp.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,62,337,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,1,0,1,0,3,0,53,8,0,
        1,0,5,0,56,8,0,10,0,12,0,59,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,3,1,71,8,1,1,2,1,2,1,2,1,2,3,2,77,8,2,1,2,1,2,1,2,1,2,1,
        2,1,2,5,2,85,8,2,10,2,12,2,88,9,2,1,2,1,2,1,2,5,2,93,8,2,10,2,12,
        2,96,9,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,5,3,105,8,3,10,3,12,3,108,9,
        3,1,3,1,3,1,3,5,3,113,8,3,10,3,12,3,116,9,3,1,3,1,3,1,4,1,4,1,4,
        1,4,1,4,5,4,125,8,4,10,4,12,4,128,9,4,1,4,1,4,1,4,5,4,133,8,4,10,
        4,12,4,136,9,4,1,4,1,4,1,5,1,5,5,5,142,8,5,10,5,12,5,145,9,5,1,5,
        1,5,1,5,5,5,150,8,5,10,5,12,5,153,9,5,1,5,1,5,1,5,5,5,158,8,5,10,
        5,12,5,161,9,5,1,5,1,5,1,6,1,6,1,6,1,6,3,6,169,8,6,1,6,1,6,1,6,1,
        6,5,6,175,8,6,10,6,12,6,178,9,6,1,6,1,6,1,6,5,6,183,8,6,10,6,12,
        6,186,9,6,1,6,3,6,189,8,6,1,6,5,6,192,8,6,10,6,12,6,195,9,6,1,6,
        1,6,1,7,1,7,1,7,5,7,202,8,7,10,7,12,7,205,9,7,3,7,207,8,7,1,8,1,
        8,1,8,1,8,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,
        11,1,11,1,12,1,12,3,12,228,8,12,1,13,1,13,1,13,1,13,1,13,1,13,1,
        13,5,13,237,8,13,10,13,12,13,240,9,13,1,13,1,13,3,13,244,8,13,1,
        14,1,14,1,15,1,15,3,15,250,8,15,1,16,1,16,1,16,1,16,1,16,1,17,1,
        17,1,17,1,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,19,1,19,1,19,1,
        19,1,20,1,20,3,20,274,8,20,1,20,1,20,1,20,3,20,279,8,20,5,20,281,
        8,20,10,20,12,20,284,9,20,3,20,286,8,20,1,21,1,21,1,21,1,21,1,21,
        1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,304,
        8,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,
        1,22,1,22,1,22,1,22,1,22,1,22,5,22,324,8,22,10,22,12,22,327,9,22,
        1,23,1,23,1,23,1,23,3,23,333,8,23,1,24,1,24,1,24,1,193,1,44,25,0,
        2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,
        48,0,6,1,0,41,43,1,0,32,34,1,0,35,36,1,0,37,40,1,0,44,45,1,0,48,
        51,361,0,57,1,0,0,0,2,70,1,0,0,0,4,72,1,0,0,0,6,99,1,0,0,0,8,119,
        1,0,0,0,10,139,1,0,0,0,12,164,1,0,0,0,14,206,1,0,0,0,16,208,1,0,
        0,0,18,212,1,0,0,0,20,215,1,0,0,0,22,219,1,0,0,0,24,227,1,0,0,0,
        26,229,1,0,0,0,28,245,1,0,0,0,30,249,1,0,0,0,32,251,1,0,0,0,34,256,
        1,0,0,0,36,260,1,0,0,0,38,267,1,0,0,0,40,285,1,0,0,0,42,287,1,0,
        0,0,44,303,1,0,0,0,46,332,1,0,0,0,48,334,1,0,0,0,50,52,3,2,1,0,51,
        53,5,61,0,0,52,51,1,0,0,0,52,53,1,0,0,0,53,56,1,0,0,0,54,56,5,61,
        0,0,55,50,1,0,0,0,55,54,1,0,0,0,56,59,1,0,0,0,57,55,1,0,0,0,57,58,
        1,0,0,0,58,1,1,0,0,0,59,57,1,0,0,0,60,71,3,4,2,0,61,71,3,6,3,0,62,
        71,3,8,4,0,63,71,3,10,5,0,64,71,3,12,6,0,65,71,3,24,12,0,66,71,3,
        26,13,0,67,71,3,34,17,0,68,71,3,36,18,0,69,71,3,38,19,0,70,60,1,
        0,0,0,70,61,1,0,0,0,70,62,1,0,0,0,70,63,1,0,0,0,70,64,1,0,0,0,70,
        65,1,0,0,0,70,66,1,0,0,0,70,67,1,0,0,0,70,68,1,0,0,0,70,69,1,0,0,
        0,71,3,1,0,0,0,72,73,5,1,0,0,73,76,5,2,0,0,74,77,3,20,10,0,75,77,
        5,53,0,0,76,74,1,0,0,0,76,75,1,0,0,0,77,78,1,0,0,0,78,79,5,3,0,0,
        79,80,3,44,22,0,80,81,5,4,0,0,81,82,3,44,22,0,82,86,5,5,0,0,83,85,
        5,61,0,0,84,83,1,0,0,0,85,88,1,0,0,0,86,84,1,0,0,0,86,87,1,0,0,0,
        87,94,1,0,0,0,88,86,1,0,0,0,89,90,3,2,1,0,90,91,5,61,0,0,91,93,1,
        0,0,0,92,89,1,0,0,0,93,96,1,0,0,0,94,92,1,0,0,0,94,95,1,0,0,0,95,
        97,1,0,0,0,96,94,1,0,0,0,97,98,5,6,0,0,98,5,1,0,0,0,99,100,5,1,0,
        0,100,101,5,7,0,0,101,102,3,44,22,0,102,106,5,5,0,0,103,105,5,61,
        0,0,104,103,1,0,0,0,105,108,1,0,0,0,106,104,1,0,0,0,106,107,1,0,
        0,0,107,114,1,0,0,0,108,106,1,0,0,0,109,110,3,2,1,0,110,111,5,61,
        0,0,111,113,1,0,0,0,112,109,1,0,0,0,113,116,1,0,0,0,114,112,1,0,
        0,0,114,115,1,0,0,0,115,117,1,0,0,0,116,114,1,0,0,0,117,118,5,6,
        0,0,118,7,1,0,0,0,119,120,5,8,0,0,120,121,3,44,22,0,121,122,5,9,
        0,0,122,126,5,10,0,0,123,125,5,61,0,0,124,123,1,0,0,0,125,128,1,
        0,0,0,126,124,1,0,0,0,126,127,1,0,0,0,127,134,1,0,0,0,128,126,1,
        0,0,0,129,130,3,2,1,0,130,131,5,61,0,0,131,133,1,0,0,0,132,129,1,
        0,0,0,133,136,1,0,0,0,134,132,1,0,0,0,134,135,1,0,0,0,135,137,1,
        0,0,0,136,134,1,0,0,0,137,138,5,11,0,0,138,9,1,0,0,0,139,143,3,8,
        4,0,140,142,5,61,0,0,141,140,1,0,0,0,142,145,1,0,0,0,143,141,1,0,
        0,0,143,144,1,0,0,0,144,146,1,0,0,0,145,143,1,0,0,0,146,147,5,12,
        0,0,147,151,5,10,0,0,148,150,5,61,0,0,149,148,1,0,0,0,150,153,1,
        0,0,0,151,149,1,0,0,0,151,152,1,0,0,0,152,159,1,0,0,0,153,151,1,
        0,0,0,154,155,3,2,1,0,155,156,5,61,0,0,156,158,1,0,0,0,157,154,1,
        0,0,0,158,161,1,0,0,0,159,157,1,0,0,0,159,160,1,0,0,0,160,162,1,
        0,0,0,161,159,1,0,0,0,162,163,5,11,0,0,163,11,1,0,0,0,164,165,5,
        13,0,0,165,168,5,53,0,0,166,167,5,14,0,0,167,169,3,14,7,0,168,166,
        1,0,0,0,168,169,1,0,0,0,169,170,1,0,0,0,170,171,5,15,0,0,171,172,
        3,48,24,0,172,176,5,16,0,0,173,175,5,61,0,0,174,173,1,0,0,0,175,
        178,1,0,0,0,176,174,1,0,0,0,176,177,1,0,0,0,177,184,1,0,0,0,178,
        176,1,0,0,0,179,180,3,2,1,0,180,181,5,61,0,0,181,183,1,0,0,0,182,
        179,1,0,0,0,183,186,1,0,0,0,184,182,1,0,0,0,184,185,1,0,0,0,185,
        188,1,0,0,0,186,184,1,0,0,0,187,189,3,18,9,0,188,187,1,0,0,0,188,
        189,1,0,0,0,189,193,1,0,0,0,190,192,5,61,0,0,191,190,1,0,0,0,192,
        195,1,0,0,0,193,194,1,0,0,0,193,191,1,0,0,0,194,196,1,0,0,0,195,
        193,1,0,0,0,196,197,5,17,0,0,197,13,1,0,0,0,198,203,3,16,8,0,199,
        200,5,18,0,0,200,202,3,16,8,0,201,199,1,0,0,0,202,205,1,0,0,0,203,
        201,1,0,0,0,203,204,1,0,0,0,204,207,1,0,0,0,205,203,1,0,0,0,206,
        198,1,0,0,0,206,207,1,0,0,0,207,15,1,0,0,0,208,209,5,19,0,0,209,
        210,3,48,24,0,210,211,5,53,0,0,211,17,1,0,0,0,212,213,5,20,0,0,213,
        214,3,44,22,0,214,19,1,0,0,0,215,216,5,19,0,0,216,217,3,48,24,0,
        217,218,5,53,0,0,218,21,1,0,0,0,219,220,5,19,0,0,220,221,3,48,24,
        0,221,222,5,53,0,0,222,223,5,21,0,0,223,224,3,44,22,0,224,23,1,0,
        0,0,225,228,3,20,10,0,226,228,3,22,11,0,227,225,1,0,0,0,227,226,
        1,0,0,0,228,25,1,0,0,0,229,230,5,22,0,0,230,231,3,48,24,0,231,232,
        5,53,0,0,232,233,5,21,0,0,233,238,3,28,14,0,234,235,5,18,0,0,235,
        237,3,28,14,0,236,234,1,0,0,0,237,240,1,0,0,0,238,236,1,0,0,0,238,
        239,1,0,0,0,239,243,1,0,0,0,240,238,1,0,0,0,241,242,5,23,0,0,242,
        244,5,55,0,0,243,241,1,0,0,0,243,244,1,0,0,0,244,27,1,0,0,0,245,
        246,3,44,22,0,246,29,1,0,0,0,247,250,5,53,0,0,248,250,3,32,16,0,
        249,247,1,0,0,0,249,248,1,0,0,0,250,31,1,0,0,0,251,252,5,24,0,0,
        252,253,3,44,22,0,253,254,5,25,0,0,254,255,3,44,22,0,255,33,1,0,
        0,0,256,257,5,53,0,0,257,258,5,21,0,0,258,259,3,44,22,0,259,35,1,
        0,0,0,260,261,5,26,0,0,261,262,3,44,22,0,262,263,5,27,0,0,263,264,
        3,44,22,0,264,265,5,28,0,0,265,266,3,44,22,0,266,37,1,0,0,0,267,
        268,5,29,0,0,268,269,5,53,0,0,269,270,3,40,20,0,270,39,1,0,0,0,271,
        274,3,24,12,0,272,274,3,44,22,0,273,271,1,0,0,0,273,272,1,0,0,0,
        274,282,1,0,0,0,275,278,5,18,0,0,276,279,3,24,12,0,277,279,3,44,
        22,0,278,276,1,0,0,0,278,277,1,0,0,0,279,281,1,0,0,0,280,275,1,0,
        0,0,281,284,1,0,0,0,282,280,1,0,0,0,282,283,1,0,0,0,283,286,1,0,
        0,0,284,282,1,0,0,0,285,273,1,0,0,0,285,286,1,0,0,0,286,41,1,0,0,
        0,287,288,5,30,0,0,288,289,3,44,22,0,289,290,5,27,0,0,290,291,3,
        48,24,0,291,43,1,0,0,0,292,293,6,22,-1,0,293,294,5,58,0,0,294,295,
        3,44,22,0,295,296,5,59,0,0,296,304,1,0,0,0,297,298,5,31,0,0,298,
        304,3,44,22,10,299,300,7,0,0,0,300,304,3,44,22,6,301,304,3,46,23,
        0,302,304,3,42,21,0,303,292,1,0,0,0,303,297,1,0,0,0,303,299,1,0,
        0,0,303,301,1,0,0,0,303,302,1,0,0,0,304,325,1,0,0,0,305,306,10,9,
        0,0,306,307,7,1,0,0,307,324,3,44,22,10,308,309,10,8,0,0,309,310,
        7,2,0,0,310,324,3,44,22,9,311,312,10,7,0,0,312,313,7,3,0,0,313,324,
        3,44,22,8,314,315,10,5,0,0,315,316,7,4,0,0,316,324,3,44,22,6,317,
        318,10,4,0,0,318,319,5,46,0,0,319,324,3,44,22,5,320,321,10,3,0,0,
        321,322,5,47,0,0,322,324,3,44,22,4,323,305,1,0,0,0,323,308,1,0,0,
        0,323,311,1,0,0,0,323,314,1,0,0,0,323,317,1,0,0,0,323,320,1,0,0,
        0,324,327,1,0,0,0,325,323,1,0,0,0,325,326,1,0,0,0,326,45,1,0,0,0,
        327,325,1,0,0,0,328,333,5,54,0,0,329,333,5,56,0,0,330,333,5,57,0,
        0,331,333,3,30,15,0,332,328,1,0,0,0,332,329,1,0,0,0,332,330,1,0,
        0,0,332,331,1,0,0,0,333,47,1,0,0,0,334,335,7,5,0,0,335,49,1,0,0,
        0,33,52,55,57,70,76,86,94,106,114,126,134,143,151,159,168,176,184,
        188,193,203,206,227,238,243,249,273,278,282,285,303,323,325,332
    ]

class kmmszarpParser ( Parser ):

    grammarFileName = "kmmszarp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'p\\u0119tla'", "'zakres'", "'od'", "'do'", 
                     "'pocz\\u0105tek p\\u0119tli'", "'koniec p\\u0119tli'", 
                     "'podczas'", "'je\\u017Celi'", "'wtedy'", "'pocz\\u0105tek je\\u017Celi'", 
                     "'koniec je\\u017Celi'", "'w przeciwnym wypadku'", 
                     "'czynno\\u015B\\u0107'", "'parametry'", "'zwraca'", 
                     "'pocz\\u0105tek czynno\\u015Bci'", "'koniec czynno\\u015Bci'", 
                     "'i'", "'zmienna'", "'zwr\\u00F3\\u0107'", "'to'", 
                     "'tablica'", "'o d\\u0142ugo\\u015Bci'", "'we\\u017A'", 
                     "'element'", "'w\\u0142\\u00F3\\u017C'", "'na'", "'miejsce'", 
                     "'wywo\\u0142aj'", "'rzu\\u0107'", "'minus'", "'razy'", 
                     "'przez'", "'modu\\u0142'", "'doda\\u0107'", "'odj\\u0105\\u0107'", 
                     "'wi\\u0119ksze ni\\u017C'", "'mniejsze ni\\u017C'", 
                     "'wi\\u0119ksze lub r\\u00F3wne'", "'mniejsze lub r\\u00F3wne'", 
                     "'przemie\\u0144'", "'zaneguj'", "'nie'", "'r\\u00F3wne'", 
                     "'nier\\u00F3wne'", "'oraz'", "'lub'", "'liczba'", 
                     "'napis'", "'prawdziwo\\u015B\\u0107'", "'nico\\u015B\\u0107'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'pocz\\u0105tek nawiasu'", 
                     "'koniec nawiasu'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "EXID", "ID", "INT", "PINT", "STRING", "BOOL", "LPAR", 
                      "RPAR", "WHITESPACE", "NEWLINE", "COMMENT" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopFor = 2
    RULE_loopWhile = 3
    RULE_conditionalStatement = 4
    RULE_conditionalStatementElse = 5
    RULE_functionDefinition = 6
    RULE_parameterList = 7
    RULE_parameter = 8
    RULE_returnStatement = 9
    RULE_pureVariableDeclaration = 10
    RULE_variableDeclarationWithAssignment = 11
    RULE_variableDeclaration = 12
    RULE_arrayDeclaration = 13
    RULE_arrayValue = 14
    RULE_variableReference = 15
    RULE_arrayAccess = 16
    RULE_variableAssignment = 17
    RULE_arrayAssignment = 18
    RULE_functionCall = 19
    RULE_argumentList = 20
    RULE_cast = 21
    RULE_expression = 22
    RULE_primary = 23
    RULE_dtype = 24

    ruleNames =  [ "program", "statement", "loopFor", "loopWhile", "conditionalStatement", 
                   "conditionalStatementElse", "functionDefinition", "parameterList", 
                   "parameter", "returnStatement", "pureVariableDeclaration", 
                   "variableDeclarationWithAssignment", "variableDeclaration", 
                   "arrayDeclaration", "arrayValue", "variableReference", 
                   "arrayAccess", "variableAssignment", "arrayAssignment", 
                   "functionCall", "argumentList", "cast", "expression", 
                   "primary", "dtype" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    EXID=52
    ID=53
    INT=54
    PINT=55
    STRING=56
    BOOL=57
    LPAR=58
    RPAR=59
    WHITESPACE=60
    NEWLINE=61
    COMMENT=62

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = kmmszarpParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 2314850209077141762) != 0):
                self.state = 55
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1, 8, 13, 19, 22, 26, 29, 53]:
                    self.state = 50
                    self.statement()
                    self.state = 52
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                    if la_ == 1:
                        self.state = 51
                        self.match(kmmszarpParser.NEWLINE)


                    pass
                elif token in [61]:
                    self.state = 54
                    self.match(kmmszarpParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopFor(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopForContext,0)


        def loopWhile(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopWhileContext,0)


        def conditionalStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalStatementContext,0)


        def conditionalStatementElse(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalStatementElseContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionDefinitionContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,0)


        def arrayDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayDeclarationContext,0)


        def variableAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableAssignmentContext,0)


        def arrayAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAssignmentContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = kmmszarpParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 70
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 60
                self.loopFor()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 61
                self.loopWhile()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 62
                self.conditionalStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 63
                self.conditionalStatementElse()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 64
                self.functionDefinition()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 65
                self.variableDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 66
                self.arrayDeclaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 67
                self.variableAssignment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 68
                self.arrayAssignment()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 69
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopForContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def pureVariableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.PureVariableDeclarationContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopFor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopFor" ):
                listener.enterLoopFor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopFor" ):
                listener.exitLoopFor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopFor" ):
                return visitor.visitLoopFor(self)
            else:
                return visitor.visitChildren(self)




    def loopFor(self):

        localctx = kmmszarpParser.LoopForContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopFor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.match(kmmszarpParser.T__0)
            self.state = 73
            self.match(kmmszarpParser.T__1)
            self.state = 76
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.state = 74
                self.pureVariableDeclaration()
                pass
            elif token in [53]:
                self.state = 75
                self.match(kmmszarpParser.ID)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 78
            self.match(kmmszarpParser.T__2)
            self.state = 79
            self.expression(0)
            self.state = 80
            self.match(kmmszarpParser.T__3)
            self.state = 81
            self.expression(0)
            self.state = 82
            self.match(kmmszarpParser.T__4)
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==61:
                self.state = 83
                self.match(kmmszarpParser.NEWLINE)
                self.state = 88
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 94
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9007199863447810) != 0):
                self.state = 89
                self.statement()
                self.state = 90
                self.match(kmmszarpParser.NEWLINE)
                self.state = 96
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 97
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopWhileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopWhile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopWhile" ):
                listener.enterLoopWhile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopWhile" ):
                listener.exitLoopWhile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopWhile" ):
                return visitor.visitLoopWhile(self)
            else:
                return visitor.visitChildren(self)




    def loopWhile(self):

        localctx = kmmszarpParser.LoopWhileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loopWhile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(kmmszarpParser.T__0)
            self.state = 100
            self.match(kmmszarpParser.T__6)
            self.state = 101
            self.expression(0)
            self.state = 102
            self.match(kmmszarpParser.T__4)
            self.state = 106
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==61:
                self.state = 103
                self.match(kmmszarpParser.NEWLINE)
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9007199863447810) != 0):
                self.state = 109
                self.statement()
                self.state = 110
                self.match(kmmszarpParser.NEWLINE)
                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 117
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_conditionalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatement" ):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatement" ):
                listener.exitConditionalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionalStatement" ):
                return visitor.visitConditionalStatement(self)
            else:
                return visitor.visitChildren(self)




    def conditionalStatement(self):

        localctx = kmmszarpParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conditionalStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(kmmszarpParser.T__7)
            self.state = 120
            self.expression(0)
            self.state = 121
            self.match(kmmszarpParser.T__8)
            self.state = 122
            self.match(kmmszarpParser.T__9)
            self.state = 126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==61:
                self.state = 123
                self.match(kmmszarpParser.NEWLINE)
                self.state = 128
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9007199863447810) != 0):
                self.state = 129
                self.statement()
                self.state = 130
                self.match(kmmszarpParser.NEWLINE)
                self.state = 136
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 137
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementElseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalStatementContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_conditionalStatementElse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatementElse" ):
                listener.enterConditionalStatementElse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatementElse" ):
                listener.exitConditionalStatementElse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionalStatementElse" ):
                return visitor.visitConditionalStatementElse(self)
            else:
                return visitor.visitChildren(self)




    def conditionalStatementElse(self):

        localctx = kmmszarpParser.ConditionalStatementElseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_conditionalStatementElse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.conditionalStatement()
            self.state = 143
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==61:
                self.state = 140
                self.match(kmmszarpParser.NEWLINE)
                self.state = 145
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 146
            self.match(kmmszarpParser.T__11)
            self.state = 147
            self.match(kmmszarpParser.T__9)
            self.state = 151
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==61:
                self.state = 148
                self.match(kmmszarpParser.NEWLINE)
                self.state = 153
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 159
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9007199863447810) != 0):
                self.state = 154
                self.statement()
                self.state = 155
                self.match(kmmszarpParser.NEWLINE)
                self.state = 161
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 162
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(kmmszarpParser.ParameterListContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def returnStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ReturnStatementContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDefinition" ):
                listener.enterFunctionDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDefinition" ):
                listener.exitFunctionDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefinition" ):
                return visitor.visitFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def functionDefinition(self):

        localctx = kmmszarpParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(kmmszarpParser.T__12)
            self.state = 165
            self.match(kmmszarpParser.ID)
            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 166
                self.match(kmmszarpParser.T__13)
                self.state = 167
                self.parameterList()


            self.state = 170
            self.match(kmmszarpParser.T__14)
            self.state = 171
            self.dtype()
            self.state = 172
            self.match(kmmszarpParser.T__15)
            self.state = 176
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 173
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 178
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 9007199863447810) != 0):
                self.state = 179
                self.statement()
                self.state = 180
                self.match(kmmszarpParser.NEWLINE)
                self.state = 186
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 187
                self.returnStatement()


            self.state = 193
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 190
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 195
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

            self.state = 196
            self.match(kmmszarpParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ParameterContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ParameterContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = kmmszarpParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 198
                self.parameter()
                self.state = 203
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 199
                    self.match(kmmszarpParser.T__17)
                    self.state = 200
                    self.parameter()
                    self.state = 205
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = kmmszarpParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(kmmszarpParser.T__18)
            self.state = 209
            self.dtype()
            self.state = 210
            self.match(kmmszarpParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = kmmszarpParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(kmmszarpParser.T__19)
            self.state = 213
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PureVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_pureVariableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPureVariableDeclaration" ):
                listener.enterPureVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPureVariableDeclaration" ):
                listener.exitPureVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPureVariableDeclaration" ):
                return visitor.visitPureVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def pureVariableDeclaration(self):

        localctx = kmmszarpParser.PureVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_pureVariableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(kmmszarpParser.T__18)
            self.state = 216
            self.dtype()
            self.state = 217
            self.match(kmmszarpParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationWithAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableDeclarationWithAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclarationWithAssignment" ):
                listener.enterVariableDeclarationWithAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclarationWithAssignment" ):
                listener.exitVariableDeclarationWithAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclarationWithAssignment" ):
                return visitor.visitVariableDeclarationWithAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclarationWithAssignment(self):

        localctx = kmmszarpParser.VariableDeclarationWithAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_variableDeclarationWithAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.match(kmmszarpParser.T__18)
            self.state = 220
            self.dtype()
            self.state = 221
            self.match(kmmszarpParser.ID)
            self.state = 222
            self.match(kmmszarpParser.T__20)
            self.state = 223
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureVariableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.PureVariableDeclarationContext,0)


        def variableDeclarationWithAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationWithAssignmentContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = kmmszarpParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_variableDeclaration)
        try:
            self.state = 227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 225
                self.pureVariableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 226
                self.variableDeclarationWithAssignment()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ArrayValueContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ArrayValueContext,i)


        def PINT(self):
            return self.getToken(kmmszarpParser.PINT, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayDeclaration" ):
                listener.enterArrayDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayDeclaration" ):
                listener.exitArrayDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayDeclaration" ):
                return visitor.visitArrayDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def arrayDeclaration(self):

        localctx = kmmszarpParser.ArrayDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_arrayDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            self.match(kmmszarpParser.T__21)
            self.state = 230
            self.dtype()
            self.state = 231
            self.match(kmmszarpParser.ID)
            self.state = 232
            self.match(kmmszarpParser.T__20)
            self.state = 233
            self.arrayValue()
            self.state = 238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 234
                self.match(kmmszarpParser.T__17)
                self.state = 235
                self.arrayValue()
                self.state = 240
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 241
                self.match(kmmszarpParser.T__22)
                self.state = 242
                self.match(kmmszarpParser.PINT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValue" ):
                listener.enterArrayValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValue" ):
                listener.exitArrayValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayValue" ):
                return visitor.visitArrayValue(self)
            else:
                return visitor.visitChildren(self)




    def arrayValue(self):

        localctx = kmmszarpParser.ArrayValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_arrayValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayAccess(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAccessContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableReference" ):
                listener.enterVariableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableReference" ):
                listener.exitVariableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableReference" ):
                return visitor.visitVariableReference(self)
            else:
                return visitor.visitChildren(self)




    def variableReference(self):

        localctx = kmmszarpParser.VariableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_variableReference)
        try:
            self.state = 249
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [53]:
                self.enterOuterAlt(localctx, 1)
                self.state = 247
                self.match(kmmszarpParser.ID)
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 248
                self.arrayAccess()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAccess" ):
                listener.enterArrayAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAccess" ):
                listener.exitArrayAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAccess" ):
                return visitor.visitArrayAccess(self)
            else:
                return visitor.visitChildren(self)




    def arrayAccess(self):

        localctx = kmmszarpParser.ArrayAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_arrayAccess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.match(kmmszarpParser.T__23)
            self.state = 252
            self.expression(0)
            self.state = 253
            self.match(kmmszarpParser.T__24)
            self.state = 254
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableAssignment" ):
                listener.enterVariableAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableAssignment" ):
                listener.exitVariableAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableAssignment" ):
                return visitor.visitVariableAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableAssignment(self):

        localctx = kmmszarpParser.VariableAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_variableAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.match(kmmszarpParser.ID)
            self.state = 257
            self.match(kmmszarpParser.T__20)
            self.state = 258
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAssignment" ):
                listener.enterArrayAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAssignment" ):
                listener.exitArrayAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAssignment" ):
                return visitor.visitArrayAssignment(self)
            else:
                return visitor.visitChildren(self)




    def arrayAssignment(self):

        localctx = kmmszarpParser.ArrayAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_arrayAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(kmmszarpParser.T__25)
            self.state = 261
            self.expression(0)
            self.state = 262
            self.match(kmmszarpParser.T__26)
            self.state = 263
            self.expression(0)
            self.state = 264
            self.match(kmmszarpParser.T__27)
            self.state = 265
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def argumentList(self):
            return self.getTypedRuleContext(kmmszarpParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = kmmszarpParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_functionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self.match(kmmszarpParser.T__28)
            self.state = 268
            self.match(kmmszarpParser.ID)
            self.state = 269
            self.argumentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = kmmszarpParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.state = 273
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 271
                    self.variableDeclaration()
                    pass
                elif token in [24, 30, 31, 41, 42, 43, 53, 54, 56, 57, 58]:
                    self.state = 272
                    self.expression(0)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 275
                    self.match(kmmszarpParser.T__17)
                    self.state = 278
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [19]:
                        self.state = 276
                        self.variableDeclaration()
                        pass
                    elif token in [24, 30, 31, 41, 42, 43, 53, 54, 56, 57, 58]:
                        self.state = 277
                        self.expression(0)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 284
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kmmszarpParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(kmmszarpParser.T__29)
            self.state = 288
            self.expression(0)
            self.state = 289
            self.match(kmmszarpParser.T__26)
            self.state = 290
            self.dtype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ParenthesizedExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAR(self):
            return self.getToken(kmmszarpParser.LPAR, 0)
        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)

        def RPAR(self):
            return self.getToken(kmmszarpParser.RPAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)


    class LogicOrContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.or_ = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)


    class MultiplicationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplication" ):
                listener.enterMultiplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplication" ):
                listener.exitMultiplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplication" ):
                return visitor.visitMultiplication(self)
            else:
                return visitor.visitChildren(self)


    class AdditionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddition" ):
                listener.enterAddition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddition" ):
                listener.exitAddition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddition" ):
                return visitor.visitAddition(self)
            else:
                return visitor.visitChildren(self)


    class NegationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNegation" ):
                listener.enterNegation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNegation" ):
                listener.exitNegation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNegation" ):
                return visitor.visitNegation(self)
            else:
                return visitor.visitChildren(self)


    class PrimaryExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primary(self):
            return self.getTypedRuleContext(kmmszarpParser.PrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpression" ):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpression" ):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpression" ):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)


    class ComparisonContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinus" ):
                listener.enterUnaryMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinus" ):
                listener.exitUnaryMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinus" ):
                return visitor.visitUnaryMinus(self)
            else:
                return visitor.visitChildren(self)


    class CastExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cast(self):
            return self.getTypedRuleContext(kmmszarpParser.CastContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastExpression" ):
                listener.enterCastExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastExpression" ):
                listener.exitCastExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastExpression" ):
                return visitor.visitCastExpression(self)
            else:
                return visitor.visitChildren(self)


    class EqualityContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.eq = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquality" ):
                listener.enterEquality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquality" ):
                listener.exitEquality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquality" ):
                return visitor.visitEquality(self)
            else:
                return visitor.visitChildren(self)


    class LogicAndContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.and_ = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = kmmszarpParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 44
        self.enterRecursionRule(localctx, 44, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [58]:
                localctx = kmmszarpParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 293
                self.match(kmmszarpParser.LPAR)
                self.state = 294
                self.expression(0)
                self.state = 295
                self.match(kmmszarpParser.RPAR)
                pass
            elif token in [31]:
                localctx = kmmszarpParser.UnaryMinusContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 297
                self.match(kmmszarpParser.T__30)
                self.state = 298
                self.expression(10)
                pass
            elif token in [41, 42, 43]:
                localctx = kmmszarpParser.NegationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 299
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 15393162788864) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 300
                self.expression(6)
                pass
            elif token in [24, 53, 54, 56, 57]:
                localctx = kmmszarpParser.PrimaryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 301
                self.primary()
                pass
            elif token in [30]:
                localctx = kmmszarpParser.CastExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 302
                self.cast()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 325
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 323
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
                    if la_ == 1:
                        localctx = kmmszarpParser.MultiplicationContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 305
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 306
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 30064771072) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 307
                        self.expression(10)
                        pass

                    elif la_ == 2:
                        localctx = kmmszarpParser.AdditionContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 308
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 309
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==35 or _la==36):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 310
                        self.expression(9)
                        pass

                    elif la_ == 3:
                        localctx = kmmszarpParser.ComparisonContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 311
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 312
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2061584302080) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 313
                        self.expression(8)
                        pass

                    elif la_ == 4:
                        localctx = kmmszarpParser.EqualityContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 314
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 315
                        localctx.eq = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==44 or _la==45):
                            localctx.eq = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 316
                        self.expression(6)
                        pass

                    elif la_ == 5:
                        localctx = kmmszarpParser.LogicAndContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 317
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 318
                        localctx.and_ = self.match(kmmszarpParser.T__45)
                        self.state = 319
                        self.expression(5)
                        pass

                    elif la_ == 6:
                        localctx = kmmszarpParser.LogicOrContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 320
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 321
                        localctx.or_ = self.match(kmmszarpParser.T__46)
                        self.state = 322
                        self.expression(4)
                        pass

             
                self.state = 327
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_primary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StringLiteralContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(kmmszarpParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class BoolLiteralContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(kmmszarpParser.BOOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolLiteral" ):
                listener.enterBoolLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolLiteral" ):
                listener.exitBoolLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolLiteral" ):
                return visitor.visitBoolLiteral(self)
            else:
                return visitor.visitChildren(self)


    class IntLiteralContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(kmmszarpParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntLiteral" ):
                listener.enterIntLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntLiteral" ):
                listener.exitIntLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntLiteral" ):
                return visitor.visitIntLiteral(self)
            else:
                return visitor.visitChildren(self)


    class VariableReferencePrimaryContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variableReference(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableReferenceContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableReferencePrimary" ):
                listener.enterVariableReferencePrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableReferencePrimary" ):
                listener.exitVariableReferencePrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableReferencePrimary" ):
                return visitor.visitVariableReferencePrimary(self)
            else:
                return visitor.visitChildren(self)



    def primary(self):

        localctx = kmmszarpParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_primary)
        try:
            self.state = 332
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [54]:
                localctx = kmmszarpParser.IntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 328
                self.match(kmmszarpParser.INT)
                pass
            elif token in [56]:
                localctx = kmmszarpParser.StringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 329
                self.match(kmmszarpParser.STRING)
                pass
            elif token in [57]:
                localctx = kmmszarpParser.BoolLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 330
                self.match(kmmszarpParser.BOOL)
                pass
            elif token in [24, 53]:
                localctx = kmmszarpParser.VariableReferencePrimaryContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 331
                self.variableReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_dtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDtype" ):
                listener.enterDtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDtype" ):
                listener.exitDtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDtype" ):
                return visitor.visitDtype(self)
            else:
                return visitor.visitChildren(self)




    def dtype(self):

        localctx = kmmszarpParser.DtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_dtype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4222124650659840) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[22] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 3)
         




