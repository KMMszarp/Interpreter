# Generated from ./kmmszarp.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,56,364,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,1,0,1,0,3,0,59,8,0,1,0,5,0,62,8,0,10,0,12,0,65,9,0,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,77,8,1,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,5,2,88,8,2,10,2,12,2,91,9,2,1,2,1,2,1,2,5,2,96,
        8,2,10,2,12,2,99,9,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,5,3,108,8,3,10,
        3,12,3,111,9,3,1,3,1,3,1,3,5,3,116,8,3,10,3,12,3,119,9,3,1,3,1,3,
        1,4,1,4,1,4,1,4,1,4,5,4,128,8,4,10,4,12,4,131,9,4,1,4,1,4,1,4,5,
        4,136,8,4,10,4,12,4,139,9,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,5,5,148,
        8,5,10,5,12,5,151,9,5,1,5,1,5,1,5,5,5,156,8,5,10,5,12,5,159,9,5,
        1,5,1,5,5,5,163,8,5,10,5,12,5,166,9,5,1,5,1,5,1,5,5,5,171,8,5,10,
        5,12,5,174,9,5,1,5,1,5,1,5,5,5,179,8,5,10,5,12,5,182,9,5,1,5,1,5,
        1,6,1,6,1,6,1,6,3,6,190,8,6,1,6,1,6,1,6,1,6,5,6,196,8,6,10,6,12,
        6,199,9,6,1,6,1,6,1,6,5,6,204,8,6,10,6,12,6,207,9,6,1,6,3,6,210,
        8,6,1,6,5,6,213,8,6,10,6,12,6,216,9,6,1,6,1,6,1,7,1,7,1,7,5,7,223,
        8,7,10,7,12,7,226,9,7,3,7,228,8,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,
        10,1,10,1,10,1,10,1,10,3,10,242,8,10,1,11,1,11,1,11,1,11,1,11,1,
        11,1,11,5,11,251,8,11,10,11,12,11,254,9,11,1,11,1,11,3,11,258,8,
        11,1,12,1,12,1,13,1,13,3,13,264,8,13,1,14,1,14,1,14,1,14,1,14,1,
        15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,1,17,1,
        17,1,17,1,18,1,18,3,18,288,8,18,1,18,1,18,1,18,3,18,293,8,18,5,18,
        295,8,18,10,18,12,18,298,9,18,3,18,300,8,18,1,19,1,19,1,20,1,20,
        1,20,5,20,307,8,20,10,20,12,20,310,9,20,1,21,1,21,1,21,5,21,315,
        8,21,10,21,12,21,318,9,21,1,22,1,22,1,22,5,22,323,8,22,10,22,12,
        22,326,9,22,1,23,1,23,1,23,5,23,331,8,23,10,23,12,23,334,9,23,1,
        24,1,24,1,24,5,24,339,8,24,10,24,12,24,342,9,24,1,25,1,25,1,25,5,
        25,347,8,25,10,25,12,25,350,9,25,1,26,1,26,1,26,1,26,1,26,1,26,1,
        26,1,26,3,26,360,8,26,1,27,1,27,1,27,1,214,0,28,0,2,4,6,8,10,12,
        14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,0,
        5,1,0,32,33,1,0,34,37,1,0,38,39,1,0,40,42,1,0,43,46,383,0,63,1,0,
        0,0,2,76,1,0,0,0,4,78,1,0,0,0,6,102,1,0,0,0,8,122,1,0,0,0,10,142,
        1,0,0,0,12,185,1,0,0,0,14,227,1,0,0,0,16,229,1,0,0,0,18,233,1,0,
        0,0,20,236,1,0,0,0,22,243,1,0,0,0,24,259,1,0,0,0,26,263,1,0,0,0,
        28,265,1,0,0,0,30,270,1,0,0,0,32,274,1,0,0,0,34,281,1,0,0,0,36,299,
        1,0,0,0,38,301,1,0,0,0,40,303,1,0,0,0,42,311,1,0,0,0,44,319,1,0,
        0,0,46,327,1,0,0,0,48,335,1,0,0,0,50,343,1,0,0,0,52,359,1,0,0,0,
        54,361,1,0,0,0,56,58,3,2,1,0,57,59,5,56,0,0,58,57,1,0,0,0,58,59,
        1,0,0,0,59,62,1,0,0,0,60,62,5,56,0,0,61,56,1,0,0,0,61,60,1,0,0,0,
        62,65,1,0,0,0,63,61,1,0,0,0,63,64,1,0,0,0,64,1,1,0,0,0,65,63,1,0,
        0,0,66,77,3,4,2,0,67,77,3,6,3,0,68,77,3,8,4,0,69,77,3,10,5,0,70,
        77,3,12,6,0,71,77,3,20,10,0,72,77,3,22,11,0,73,77,3,30,15,0,74,77,
        3,32,16,0,75,77,3,34,17,0,76,66,1,0,0,0,76,67,1,0,0,0,76,68,1,0,
        0,0,76,69,1,0,0,0,76,70,1,0,0,0,76,71,1,0,0,0,76,72,1,0,0,0,76,73,
        1,0,0,0,76,74,1,0,0,0,76,75,1,0,0,0,77,3,1,0,0,0,78,79,5,1,0,0,79,
        80,5,2,0,0,80,81,3,20,10,0,81,82,5,3,0,0,82,83,3,38,19,0,83,84,5,
        4,0,0,84,85,3,38,19,0,85,89,5,5,0,0,86,88,5,56,0,0,87,86,1,0,0,0,
        88,91,1,0,0,0,89,87,1,0,0,0,89,90,1,0,0,0,90,97,1,0,0,0,91,89,1,
        0,0,0,92,93,3,2,1,0,93,94,5,56,0,0,94,96,1,0,0,0,95,92,1,0,0,0,96,
        99,1,0,0,0,97,95,1,0,0,0,97,98,1,0,0,0,98,100,1,0,0,0,99,97,1,0,
        0,0,100,101,5,6,0,0,101,5,1,0,0,0,102,103,5,1,0,0,103,104,5,7,0,
        0,104,105,3,38,19,0,105,109,5,5,0,0,106,108,5,56,0,0,107,106,1,0,
        0,0,108,111,1,0,0,0,109,107,1,0,0,0,109,110,1,0,0,0,110,117,1,0,
        0,0,111,109,1,0,0,0,112,113,3,2,1,0,113,114,5,56,0,0,114,116,1,0,
        0,0,115,112,1,0,0,0,116,119,1,0,0,0,117,115,1,0,0,0,117,118,1,0,
        0,0,118,120,1,0,0,0,119,117,1,0,0,0,120,121,5,6,0,0,121,7,1,0,0,
        0,122,123,5,8,0,0,123,124,3,38,19,0,124,125,5,9,0,0,125,129,5,10,
        0,0,126,128,5,56,0,0,127,126,1,0,0,0,128,131,1,0,0,0,129,127,1,0,
        0,0,129,130,1,0,0,0,130,137,1,0,0,0,131,129,1,0,0,0,132,133,3,2,
        1,0,133,134,5,56,0,0,134,136,1,0,0,0,135,132,1,0,0,0,136,139,1,0,
        0,0,137,135,1,0,0,0,137,138,1,0,0,0,138,140,1,0,0,0,139,137,1,0,
        0,0,140,141,5,11,0,0,141,9,1,0,0,0,142,143,5,8,0,0,143,144,3,38,
        19,0,144,145,5,9,0,0,145,149,5,10,0,0,146,148,5,56,0,0,147,146,1,
        0,0,0,148,151,1,0,0,0,149,147,1,0,0,0,149,150,1,0,0,0,150,157,1,
        0,0,0,151,149,1,0,0,0,152,153,3,2,1,0,153,154,5,56,0,0,154,156,1,
        0,0,0,155,152,1,0,0,0,156,159,1,0,0,0,157,155,1,0,0,0,157,158,1,
        0,0,0,158,160,1,0,0,0,159,157,1,0,0,0,160,164,5,11,0,0,161,163,5,
        56,0,0,162,161,1,0,0,0,163,166,1,0,0,0,164,162,1,0,0,0,164,165,1,
        0,0,0,165,167,1,0,0,0,166,164,1,0,0,0,167,168,5,12,0,0,168,172,5,
        10,0,0,169,171,5,56,0,0,170,169,1,0,0,0,171,174,1,0,0,0,172,170,
        1,0,0,0,172,173,1,0,0,0,173,180,1,0,0,0,174,172,1,0,0,0,175,176,
        3,2,1,0,176,177,5,56,0,0,177,179,1,0,0,0,178,175,1,0,0,0,179,182,
        1,0,0,0,180,178,1,0,0,0,180,181,1,0,0,0,181,183,1,0,0,0,182,180,
        1,0,0,0,183,184,5,11,0,0,184,11,1,0,0,0,185,186,5,13,0,0,186,189,
        5,48,0,0,187,188,5,14,0,0,188,190,3,14,7,0,189,187,1,0,0,0,189,190,
        1,0,0,0,190,191,1,0,0,0,191,192,5,15,0,0,192,193,3,54,27,0,193,197,
        5,16,0,0,194,196,5,56,0,0,195,194,1,0,0,0,196,199,1,0,0,0,197,195,
        1,0,0,0,197,198,1,0,0,0,198,205,1,0,0,0,199,197,1,0,0,0,200,201,
        3,2,1,0,201,202,5,56,0,0,202,204,1,0,0,0,203,200,1,0,0,0,204,207,
        1,0,0,0,205,203,1,0,0,0,205,206,1,0,0,0,206,209,1,0,0,0,207,205,
        1,0,0,0,208,210,3,18,9,0,209,208,1,0,0,0,209,210,1,0,0,0,210,214,
        1,0,0,0,211,213,5,56,0,0,212,211,1,0,0,0,213,216,1,0,0,0,214,215,
        1,0,0,0,214,212,1,0,0,0,215,217,1,0,0,0,216,214,1,0,0,0,217,218,
        5,17,0,0,218,13,1,0,0,0,219,224,3,16,8,0,220,221,5,18,0,0,221,223,
        3,16,8,0,222,220,1,0,0,0,223,226,1,0,0,0,224,222,1,0,0,0,224,225,
        1,0,0,0,225,228,1,0,0,0,226,224,1,0,0,0,227,219,1,0,0,0,227,228,
        1,0,0,0,228,15,1,0,0,0,229,230,5,19,0,0,230,231,3,54,27,0,231,232,
        5,48,0,0,232,17,1,0,0,0,233,234,5,20,0,0,234,235,3,38,19,0,235,19,
        1,0,0,0,236,237,5,19,0,0,237,238,3,54,27,0,238,241,5,48,0,0,239,
        240,5,21,0,0,240,242,3,38,19,0,241,239,1,0,0,0,241,242,1,0,0,0,242,
        21,1,0,0,0,243,244,5,22,0,0,244,245,3,54,27,0,245,246,5,48,0,0,246,
        247,5,21,0,0,247,252,3,24,12,0,248,249,5,18,0,0,249,251,3,24,12,
        0,250,248,1,0,0,0,251,254,1,0,0,0,252,250,1,0,0,0,252,253,1,0,0,
        0,253,257,1,0,0,0,254,252,1,0,0,0,255,256,5,23,0,0,256,258,5,50,
        0,0,257,255,1,0,0,0,257,258,1,0,0,0,258,23,1,0,0,0,259,260,3,38,
        19,0,260,25,1,0,0,0,261,264,5,48,0,0,262,264,3,28,14,0,263,261,1,
        0,0,0,263,262,1,0,0,0,264,27,1,0,0,0,265,266,5,24,0,0,266,267,3,
        38,19,0,267,268,5,25,0,0,268,269,3,38,19,0,269,29,1,0,0,0,270,271,
        5,48,0,0,271,272,5,21,0,0,272,273,3,38,19,0,273,31,1,0,0,0,274,275,
        5,26,0,0,275,276,3,38,19,0,276,277,5,27,0,0,277,278,3,38,19,0,278,
        279,5,28,0,0,279,280,3,38,19,0,280,33,1,0,0,0,281,282,5,29,0,0,282,
        283,5,48,0,0,283,284,3,36,18,0,284,35,1,0,0,0,285,288,3,20,10,0,
        286,288,3,38,19,0,287,285,1,0,0,0,287,286,1,0,0,0,288,296,1,0,0,
        0,289,292,5,18,0,0,290,293,3,20,10,0,291,293,3,38,19,0,292,290,1,
        0,0,0,292,291,1,0,0,0,293,295,1,0,0,0,294,289,1,0,0,0,295,298,1,
        0,0,0,296,294,1,0,0,0,296,297,1,0,0,0,297,300,1,0,0,0,298,296,1,
        0,0,0,299,287,1,0,0,0,299,300,1,0,0,0,300,37,1,0,0,0,301,302,3,40,
        20,0,302,39,1,0,0,0,303,308,3,42,21,0,304,305,5,30,0,0,305,307,3,
        42,21,0,306,304,1,0,0,0,307,310,1,0,0,0,308,306,1,0,0,0,308,309,
        1,0,0,0,309,41,1,0,0,0,310,308,1,0,0,0,311,316,3,44,22,0,312,313,
        5,31,0,0,313,315,3,44,22,0,314,312,1,0,0,0,315,318,1,0,0,0,316,314,
        1,0,0,0,316,317,1,0,0,0,317,43,1,0,0,0,318,316,1,0,0,0,319,324,3,
        46,23,0,320,321,7,0,0,0,321,323,3,46,23,0,322,320,1,0,0,0,323,326,
        1,0,0,0,324,322,1,0,0,0,324,325,1,0,0,0,325,45,1,0,0,0,326,324,1,
        0,0,0,327,332,3,48,24,0,328,329,7,1,0,0,329,331,3,48,24,0,330,328,
        1,0,0,0,331,334,1,0,0,0,332,330,1,0,0,0,332,333,1,0,0,0,333,47,1,
        0,0,0,334,332,1,0,0,0,335,340,3,50,25,0,336,337,7,2,0,0,337,339,
        3,50,25,0,338,336,1,0,0,0,339,342,1,0,0,0,340,338,1,0,0,0,340,341,
        1,0,0,0,341,49,1,0,0,0,342,340,1,0,0,0,343,348,3,52,26,0,344,345,
        7,3,0,0,345,347,3,52,26,0,346,344,1,0,0,0,347,350,1,0,0,0,348,346,
        1,0,0,0,348,349,1,0,0,0,349,51,1,0,0,0,350,348,1,0,0,0,351,360,5,
        49,0,0,352,360,5,51,0,0,353,360,5,52,0,0,354,360,3,26,13,0,355,356,
        5,53,0,0,356,357,3,38,19,0,357,358,5,54,0,0,358,360,1,0,0,0,359,
        351,1,0,0,0,359,352,1,0,0,0,359,353,1,0,0,0,359,354,1,0,0,0,359,
        355,1,0,0,0,360,53,1,0,0,0,361,362,7,4,0,0,362,55,1,0,0,0,37,58,
        61,63,76,89,97,109,117,129,137,149,157,164,172,180,189,197,205,209,
        214,224,227,241,252,257,263,287,292,296,299,308,316,324,332,340,
        348,359
    ]

class kmmszarpParser ( Parser ):

    grammarFileName = "kmmszarp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'p\\u0119tla'", "'zakres'", "'od'", "'do'", 
                     "'pocz\\u0105tek p\\u0119tli'", "'koniec p\\u0119tli'", 
                     "'podczas'", "'je\\u017Celi'", "'wtedy'", "'pocz\\u0105tek je\\u017Celi'", 
                     "'koniec je\\u017Celi'", "'w przeciwnym wypadku'", 
                     "'czynno\\u015B\\u0107'", "'parametry'", "'zwraca'", 
                     "'pocz\\u0105tek czynno\\u015Bci'", "'koniec czynno\\u015Bci'", 
                     "'i'", "'zmienna'", "'zwr\\u00F3\\u0107'", "'to'", 
                     "'tablica'", "'o d\\u0142ugo\\u015Bci'", "'we\\u017A'", 
                     "'element'", "'w\\u0142\\u00F3\\u017C'", "'na'", "'miejsce'", 
                     "'wywo\\u0142aj'", "'lub'", "'oraz'", "'r\\u00F3wne'", 
                     "'nier\\u00F3wne'", "'wi\\u0119ksze ni\\u017C'", "'mniejsze ni\\u017C'", 
                     "'wi\\u0119ksze lub r\\u00F3wne'", "'mniejsze lub r\\u00F3wne'", 
                     "'doda\\u0107'", "'odj\\u0105\\u0107'", "'razy'", "'przez'", 
                     "'modu\\u0142'", "'liczba'", "'napis'", "'prawdziwo\\u015B\\u0107'", 
                     "'nico\\u015B\\u0107'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'pocz\\u0105tek nawiasu'", 
                     "'koniec nawiasu'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "ULID", "ID", 
                      "INT", "PINT", "STRING", "BOOL", "LPAR", "RPAR", "WHITESPACE", 
                      "NEWLINE" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopFor = 2
    RULE_loopWhile = 3
    RULE_conditional = 4
    RULE_ifelse = 5
    RULE_functionDefinition = 6
    RULE_parameterList = 7
    RULE_parameter = 8
    RULE_returnStatement = 9
    RULE_variableDeclaration = 10
    RULE_arrayDeclaration = 11
    RULE_arrayValue = 12
    RULE_variableReference = 13
    RULE_arrayAccess = 14
    RULE_variableAssignment = 15
    RULE_arrayAssignment = 16
    RULE_functionCall = 17
    RULE_argumentList = 18
    RULE_expression = 19
    RULE_logicOr = 20
    RULE_logicAnd = 21
    RULE_equality = 22
    RULE_comparison = 23
    RULE_addition = 24
    RULE_multiplication = 25
    RULE_primary = 26
    RULE_type = 27

    ruleNames =  [ "program", "statement", "loopFor", "loopWhile", "conditional", 
                   "ifelse", "functionDefinition", "parameterList", "parameter", 
                   "returnStatement", "variableDeclaration", "arrayDeclaration", 
                   "arrayValue", "variableReference", "arrayAccess", "variableAssignment", 
                   "arrayAssignment", "functionCall", "argumentList", "expression", 
                   "logicOr", "logicAnd", "equality", "comparison", "addition", 
                   "multiplication", "primary", "type" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    ULID=47
    ID=48
    INT=49
    PINT=50
    STRING=51
    BOOL=52
    LPAR=53
    RPAR=54
    WHITESPACE=55
    NEWLINE=56

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = kmmszarpParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 72339069623345410) != 0):
                self.state = 61
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1, 8, 13, 19, 22, 26, 29, 48]:
                    self.state = 56
                    self.statement()
                    self.state = 58
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                    if la_ == 1:
                        self.state = 57
                        self.match(kmmszarpParser.NEWLINE)


                    pass
                elif token in [56]:
                    self.state = 60
                    self.match(kmmszarpParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopFor(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopForContext,0)


        def loopWhile(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopWhileContext,0)


        def conditional(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalContext,0)


        def ifelse(self):
            return self.getTypedRuleContext(kmmszarpParser.IfelseContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionDefinitionContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,0)


        def arrayDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayDeclarationContext,0)


        def variableAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableAssignmentContext,0)


        def arrayAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAssignmentContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = kmmszarpParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 76
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 66
                self.loopFor()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 67
                self.loopWhile()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 68
                self.conditional()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 69
                self.ifelse()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 70
                self.functionDefinition()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 71
                self.variableDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 72
                self.arrayDeclaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 73
                self.variableAssignment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 74
                self.arrayAssignment()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 75
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopForContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopFor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopFor" ):
                listener.enterLoopFor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopFor" ):
                listener.exitLoopFor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopFor" ):
                return visitor.visitLoopFor(self)
            else:
                return visitor.visitChildren(self)




    def loopFor(self):

        localctx = kmmszarpParser.LoopForContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopFor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(kmmszarpParser.T__0)
            self.state = 79
            self.match(kmmszarpParser.T__1)
            self.state = 80
            self.variableDeclaration()
            self.state = 81
            self.match(kmmszarpParser.T__2)
            self.state = 82
            self.expression()
            self.state = 83
            self.match(kmmszarpParser.T__3)
            self.state = 84
            self.expression()
            self.state = 85
            self.match(kmmszarpParser.T__4)
            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 86
                self.match(kmmszarpParser.NEWLINE)
                self.state = 91
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 281475585417474) != 0):
                self.state = 92
                self.statement()
                self.state = 93
                self.match(kmmszarpParser.NEWLINE)
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 100
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopWhileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopWhile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopWhile" ):
                listener.enterLoopWhile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopWhile" ):
                listener.exitLoopWhile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopWhile" ):
                return visitor.visitLoopWhile(self)
            else:
                return visitor.visitChildren(self)




    def loopWhile(self):

        localctx = kmmszarpParser.LoopWhileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loopWhile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(kmmszarpParser.T__0)
            self.state = 103
            self.match(kmmszarpParser.T__6)
            self.state = 104
            self.expression()
            self.state = 105
            self.match(kmmszarpParser.T__4)
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 106
                self.match(kmmszarpParser.NEWLINE)
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 281475585417474) != 0):
                self.state = 112
                self.statement()
                self.state = 113
                self.match(kmmszarpParser.NEWLINE)
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 120
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional" ):
                listener.enterConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional" ):
                listener.exitConditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditional" ):
                return visitor.visitConditional(self)
            else:
                return visitor.visitChildren(self)




    def conditional(self):

        localctx = kmmszarpParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conditional)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(kmmszarpParser.T__7)
            self.state = 123
            self.expression()
            self.state = 124
            self.match(kmmszarpParser.T__8)
            self.state = 125
            self.match(kmmszarpParser.T__9)
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 126
                self.match(kmmszarpParser.NEWLINE)
                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 281475585417474) != 0):
                self.state = 132
                self.statement()
                self.state = 133
                self.match(kmmszarpParser.NEWLINE)
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 140
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfelseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_ifelse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfelse" ):
                listener.enterIfelse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfelse" ):
                listener.exitIfelse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfelse" ):
                return visitor.visitIfelse(self)
            else:
                return visitor.visitChildren(self)




    def ifelse(self):

        localctx = kmmszarpParser.IfelseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ifelse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(kmmszarpParser.T__7)
            self.state = 143
            self.expression()
            self.state = 144
            self.match(kmmszarpParser.T__8)
            self.state = 145
            self.match(kmmszarpParser.T__9)
            self.state = 149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 146
                self.match(kmmszarpParser.NEWLINE)
                self.state = 151
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 281475585417474) != 0):
                self.state = 152
                self.statement()
                self.state = 153
                self.match(kmmszarpParser.NEWLINE)
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 160
            self.match(kmmszarpParser.T__10)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 161
                self.match(kmmszarpParser.NEWLINE)
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 167
            self.match(kmmszarpParser.T__11)
            self.state = 168
            self.match(kmmszarpParser.T__9)
            self.state = 172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==56:
                self.state = 169
                self.match(kmmszarpParser.NEWLINE)
                self.state = 174
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 281475585417474) != 0):
                self.state = 175
                self.statement()
                self.state = 176
                self.match(kmmszarpParser.NEWLINE)
                self.state = 182
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 183
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(kmmszarpParser.ParameterListContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def returnStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ReturnStatementContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDefinition" ):
                listener.enterFunctionDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDefinition" ):
                listener.exitFunctionDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefinition" ):
                return visitor.visitFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def functionDefinition(self):

        localctx = kmmszarpParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(kmmszarpParser.T__12)
            self.state = 186
            self.match(kmmszarpParser.ID)
            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 187
                self.match(kmmszarpParser.T__13)
                self.state = 188
                self.parameterList()


            self.state = 191
            self.match(kmmszarpParser.T__14)
            self.state = 192
            self.type_()
            self.state = 193
            self.match(kmmszarpParser.T__15)
            self.state = 197
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 194
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 199
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 281475585417474) != 0):
                self.state = 200
                self.statement()
                self.state = 201
                self.match(kmmszarpParser.NEWLINE)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 209
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 208
                self.returnStatement()


            self.state = 214
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 211
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 216
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

            self.state = 217
            self.match(kmmszarpParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ParameterContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ParameterContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = kmmszarpParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 219
                self.parameter()
                self.state = 224
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 220
                    self.match(kmmszarpParser.T__17)
                    self.state = 221
                    self.parameter()
                    self.state = 226
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = kmmszarpParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            self.match(kmmszarpParser.T__18)
            self.state = 230
            self.type_()
            self.state = 231
            self.match(kmmszarpParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = kmmszarpParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(kmmszarpParser.T__19)
            self.state = 234
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = kmmszarpParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(kmmszarpParser.T__18)
            self.state = 237
            self.type_()
            self.state = 238
            self.match(kmmszarpParser.ID)
            self.state = 241
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 239
                self.match(kmmszarpParser.T__20)
                self.state = 240
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ArrayValueContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ArrayValueContext,i)


        def PINT(self):
            return self.getToken(kmmszarpParser.PINT, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayDeclaration" ):
                listener.enterArrayDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayDeclaration" ):
                listener.exitArrayDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayDeclaration" ):
                return visitor.visitArrayDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def arrayDeclaration(self):

        localctx = kmmszarpParser.ArrayDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_arrayDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.match(kmmszarpParser.T__21)
            self.state = 244
            self.type_()
            self.state = 245
            self.match(kmmszarpParser.ID)
            self.state = 246
            self.match(kmmszarpParser.T__20)
            self.state = 247
            self.arrayValue()
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 248
                self.match(kmmszarpParser.T__17)
                self.state = 249
                self.arrayValue()
                self.state = 254
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 255
                self.match(kmmszarpParser.T__22)
                self.state = 256
                self.match(kmmszarpParser.PINT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValue" ):
                listener.enterArrayValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValue" ):
                listener.exitArrayValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayValue" ):
                return visitor.visitArrayValue(self)
            else:
                return visitor.visitChildren(self)




    def arrayValue(self):

        localctx = kmmszarpParser.ArrayValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arrayValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayAccess(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAccessContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableReference" ):
                listener.enterVariableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableReference" ):
                listener.exitVariableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableReference" ):
                return visitor.visitVariableReference(self)
            else:
                return visitor.visitChildren(self)




    def variableReference(self):

        localctx = kmmszarpParser.VariableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_variableReference)
        try:
            self.state = 263
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 261
                self.match(kmmszarpParser.ID)
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 262
                self.arrayAccess()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAccess" ):
                listener.enterArrayAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAccess" ):
                listener.exitArrayAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAccess" ):
                return visitor.visitArrayAccess(self)
            else:
                return visitor.visitChildren(self)




    def arrayAccess(self):

        localctx = kmmszarpParser.ArrayAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_arrayAccess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(kmmszarpParser.T__23)
            self.state = 266
            self.expression()
            self.state = 267
            self.match(kmmszarpParser.T__24)
            self.state = 268
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableAssignment" ):
                listener.enterVariableAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableAssignment" ):
                listener.exitVariableAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableAssignment" ):
                return visitor.visitVariableAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableAssignment(self):

        localctx = kmmszarpParser.VariableAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_variableAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(kmmszarpParser.ID)
            self.state = 271
            self.match(kmmszarpParser.T__20)
            self.state = 272
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAssignment" ):
                listener.enterArrayAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAssignment" ):
                listener.exitArrayAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAssignment" ):
                return visitor.visitArrayAssignment(self)
            else:
                return visitor.visitChildren(self)




    def arrayAssignment(self):

        localctx = kmmszarpParser.ArrayAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_arrayAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(kmmszarpParser.T__25)
            self.state = 275
            self.expression()
            self.state = 276
            self.match(kmmszarpParser.T__26)
            self.state = 277
            self.expression()
            self.state = 278
            self.match(kmmszarpParser.T__27)
            self.state = 279
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def argumentList(self):
            return self.getTypedRuleContext(kmmszarpParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = kmmszarpParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_functionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 281
            self.match(kmmszarpParser.T__28)
            self.state = 282
            self.match(kmmszarpParser.ID)
            self.state = 283
            self.argumentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = kmmszarpParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.state = 287
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 285
                    self.variableDeclaration()
                    pass
                elif token in [24, 48, 49, 51, 52, 53]:
                    self.state = 286
                    self.expression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 296
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 289
                    self.match(kmmszarpParser.T__17)
                    self.state = 292
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [19]:
                        self.state = 290
                        self.variableDeclaration()
                        pass
                    elif token in [24, 48, 49, 51, 52, 53]:
                        self.state = 291
                        self.expression()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 298
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicOr(self):
            return self.getTypedRuleContext(kmmszarpParser.LogicOrContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = kmmszarpParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.logicOr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicOrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicAnd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.LogicAndContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.LogicAndContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_logicOr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)




    def logicOr(self):

        localctx = kmmszarpParser.LogicOrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_logicOr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.logicAnd()
            self.state = 308
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,30,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 304
                    self.match(kmmszarpParser.T__29)
                    self.state = 305
                    self.logicAnd() 
                self.state = 310
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicAndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equality(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.EqualityContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.EqualityContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_logicAnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)




    def logicAnd(self):

        localctx = kmmszarpParser.LogicAndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_logicAnd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.equality()
            self.state = 316
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 312
                    self.match(kmmszarpParser.T__30)
                    self.state = 313
                    self.equality() 
                self.state = 318
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ComparisonContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_equality

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquality" ):
                listener.enterEquality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquality" ):
                listener.exitEquality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquality" ):
                return visitor.visitEquality(self)
            else:
                return visitor.visitChildren(self)




    def equality(self):

        localctx = kmmszarpParser.EqualityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_equality)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.comparison()
            self.state = 324
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 320
                    _la = self._input.LA(1)
                    if not(_la==32 or _la==33):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 321
                    self.comparison() 
                self.state = 326
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.AdditionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.AdditionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kmmszarpParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.addition()
            self.state = 332
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 328
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 257698037760) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 329
                    self.addition() 
                self.state = 334
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplication(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.MultiplicationContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.MultiplicationContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_addition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddition" ):
                listener.enterAddition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddition" ):
                listener.exitAddition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddition" ):
                return visitor.visitAddition(self)
            else:
                return visitor.visitChildren(self)




    def addition(self):

        localctx = kmmszarpParser.AdditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_addition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.multiplication()
            self.state = 340
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,34,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 336
                    _la = self._input.LA(1)
                    if not(_la==38 or _la==39):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 337
                    self.multiplication() 
                self.state = 342
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.PrimaryContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.PrimaryContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_multiplication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplication" ):
                listener.enterMultiplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplication" ):
                listener.exitMultiplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplication" ):
                return visitor.visitMultiplication(self)
            else:
                return visitor.visitChildren(self)




    def multiplication(self):

        localctx = kmmszarpParser.MultiplicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_multiplication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            self.primary()
            self.state = 348
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 344
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 345
                    self.primary() 
                self.state = 350
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(kmmszarpParser.INT, 0)

        def STRING(self):
            return self.getToken(kmmszarpParser.STRING, 0)

        def BOOL(self):
            return self.getToken(kmmszarpParser.BOOL, 0)

        def variableReference(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableReferenceContext,0)


        def LPAR(self):
            return self.getToken(kmmszarpParser.LPAR, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def RPAR(self):
            return self.getToken(kmmszarpParser.RPAR, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary" ):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)




    def primary(self):

        localctx = kmmszarpParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_primary)
        try:
            self.state = 359
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [49]:
                self.enterOuterAlt(localctx, 1)
                self.state = 351
                self.match(kmmszarpParser.INT)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 2)
                self.state = 352
                self.match(kmmszarpParser.STRING)
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 3)
                self.state = 353
                self.match(kmmszarpParser.BOOL)
                pass
            elif token in [24, 48]:
                self.enterOuterAlt(localctx, 4)
                self.state = 354
                self.variableReference()
                pass
            elif token in [53]:
                self.enterOuterAlt(localctx, 5)
                self.state = 355
                self.match(kmmszarpParser.LPAR)
                self.state = 356
                self.expression()
                self.state = 357
                self.match(kmmszarpParser.RPAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)




    def type_(self):

        localctx = kmmszarpParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 131941395333120) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





