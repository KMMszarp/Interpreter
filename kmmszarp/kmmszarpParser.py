# Generated from ./kmmszarp.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,60,335,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,1,0,1,0,3,0,53,8,0,
        1,0,5,0,56,8,0,10,0,12,0,59,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,3,1,72,8,1,1,2,1,2,1,2,1,2,3,2,78,8,2,1,2,1,2,1,2,1,
        2,1,2,1,2,5,2,86,8,2,10,2,12,2,89,9,2,1,2,1,2,1,2,5,2,94,8,2,10,
        2,12,2,97,9,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,5,3,106,8,3,10,3,12,3,
        109,9,3,1,3,1,3,1,3,5,3,114,8,3,10,3,12,3,117,9,3,1,3,1,3,1,4,1,
        4,1,4,1,4,1,4,5,4,126,8,4,10,4,12,4,129,9,4,1,4,1,4,1,4,5,4,134,
        8,4,10,4,12,4,137,9,4,1,4,1,4,1,5,1,5,5,5,143,8,5,10,5,12,5,146,
        9,5,1,5,1,5,1,5,5,5,151,8,5,10,5,12,5,154,9,5,1,5,1,5,1,5,5,5,159,
        8,5,10,5,12,5,162,9,5,1,5,1,5,1,6,1,6,1,6,1,6,3,6,170,8,6,1,6,1,
        6,1,6,1,6,5,6,176,8,6,10,6,12,6,179,9,6,1,6,1,6,1,6,5,6,184,8,6,
        10,6,12,6,187,9,6,1,6,3,6,190,8,6,1,6,5,6,193,8,6,10,6,12,6,196,
        9,6,1,6,1,6,1,7,1,7,1,7,5,7,203,8,7,10,7,12,7,206,9,7,3,7,208,8,
        7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,11,1,11,1,11,
        1,11,1,11,1,11,1,12,1,12,3,12,229,8,12,1,13,1,13,1,13,1,13,1,13,
        1,13,1,13,5,13,238,8,13,10,13,12,13,241,9,13,1,13,1,13,3,13,245,
        8,13,1,14,1,14,1,15,1,15,3,15,251,8,15,1,16,1,16,1,16,1,16,1,16,
        1,17,1,17,1,17,1,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,19,1,19,
        1,19,1,19,1,20,1,20,3,20,275,8,20,1,20,1,20,1,20,3,20,280,8,20,5,
        20,282,8,20,10,20,12,20,285,9,20,3,20,287,8,20,1,21,1,21,1,21,1,
        21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,302,8,22,1,
        22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,
        22,1,22,1,22,1,22,1,22,5,22,322,8,22,10,22,12,22,325,9,22,1,23,1,
        23,1,23,1,23,3,23,331,8,23,1,24,1,24,1,24,1,194,1,44,25,0,2,4,6,
        8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,0,
        6,1,0,40,42,1,0,31,33,1,0,34,35,1,0,36,39,1,0,43,44,1,0,47,50,358,
        0,57,1,0,0,0,2,71,1,0,0,0,4,73,1,0,0,0,6,100,1,0,0,0,8,120,1,0,0,
        0,10,140,1,0,0,0,12,165,1,0,0,0,14,207,1,0,0,0,16,209,1,0,0,0,18,
        213,1,0,0,0,20,216,1,0,0,0,22,220,1,0,0,0,24,228,1,0,0,0,26,230,
        1,0,0,0,28,246,1,0,0,0,30,250,1,0,0,0,32,252,1,0,0,0,34,257,1,0,
        0,0,36,261,1,0,0,0,38,268,1,0,0,0,40,286,1,0,0,0,42,288,1,0,0,0,
        44,301,1,0,0,0,46,330,1,0,0,0,48,332,1,0,0,0,50,52,3,2,1,0,51,53,
        5,60,0,0,52,51,1,0,0,0,52,53,1,0,0,0,53,56,1,0,0,0,54,56,5,60,0,
        0,55,50,1,0,0,0,55,54,1,0,0,0,56,59,1,0,0,0,57,55,1,0,0,0,57,58,
        1,0,0,0,58,1,1,0,0,0,59,57,1,0,0,0,60,72,3,4,2,0,61,72,3,6,3,0,62,
        72,3,8,4,0,63,72,3,10,5,0,64,72,3,12,6,0,65,72,3,24,12,0,66,72,3,
        26,13,0,67,72,3,34,17,0,68,72,3,36,18,0,69,72,3,38,19,0,70,72,3,
        42,21,0,71,60,1,0,0,0,71,61,1,0,0,0,71,62,1,0,0,0,71,63,1,0,0,0,
        71,64,1,0,0,0,71,65,1,0,0,0,71,66,1,0,0,0,71,67,1,0,0,0,71,68,1,
        0,0,0,71,69,1,0,0,0,71,70,1,0,0,0,72,3,1,0,0,0,73,74,5,1,0,0,74,
        77,5,2,0,0,75,78,3,20,10,0,76,78,5,52,0,0,77,75,1,0,0,0,77,76,1,
        0,0,0,78,79,1,0,0,0,79,80,5,3,0,0,80,81,3,44,22,0,81,82,5,4,0,0,
        82,83,3,44,22,0,83,87,5,5,0,0,84,86,5,60,0,0,85,84,1,0,0,0,86,89,
        1,0,0,0,87,85,1,0,0,0,87,88,1,0,0,0,88,95,1,0,0,0,89,87,1,0,0,0,
        90,91,3,2,1,0,91,92,5,60,0,0,92,94,1,0,0,0,93,90,1,0,0,0,94,97,1,
        0,0,0,95,93,1,0,0,0,95,96,1,0,0,0,96,98,1,0,0,0,97,95,1,0,0,0,98,
        99,5,6,0,0,99,5,1,0,0,0,100,101,5,1,0,0,101,102,5,7,0,0,102,103,
        3,44,22,0,103,107,5,5,0,0,104,106,5,60,0,0,105,104,1,0,0,0,106,109,
        1,0,0,0,107,105,1,0,0,0,107,108,1,0,0,0,108,115,1,0,0,0,109,107,
        1,0,0,0,110,111,3,2,1,0,111,112,5,60,0,0,112,114,1,0,0,0,113,110,
        1,0,0,0,114,117,1,0,0,0,115,113,1,0,0,0,115,116,1,0,0,0,116,118,
        1,0,0,0,117,115,1,0,0,0,118,119,5,6,0,0,119,7,1,0,0,0,120,121,5,
        8,0,0,121,122,3,44,22,0,122,123,5,9,0,0,123,127,5,10,0,0,124,126,
        5,60,0,0,125,124,1,0,0,0,126,129,1,0,0,0,127,125,1,0,0,0,127,128,
        1,0,0,0,128,135,1,0,0,0,129,127,1,0,0,0,130,131,3,2,1,0,131,132,
        5,60,0,0,132,134,1,0,0,0,133,130,1,0,0,0,134,137,1,0,0,0,135,133,
        1,0,0,0,135,136,1,0,0,0,136,138,1,0,0,0,137,135,1,0,0,0,138,139,
        5,11,0,0,139,9,1,0,0,0,140,144,3,8,4,0,141,143,5,60,0,0,142,141,
        1,0,0,0,143,146,1,0,0,0,144,142,1,0,0,0,144,145,1,0,0,0,145,147,
        1,0,0,0,146,144,1,0,0,0,147,148,5,12,0,0,148,152,5,10,0,0,149,151,
        5,60,0,0,150,149,1,0,0,0,151,154,1,0,0,0,152,150,1,0,0,0,152,153,
        1,0,0,0,153,160,1,0,0,0,154,152,1,0,0,0,155,156,3,2,1,0,156,157,
        5,60,0,0,157,159,1,0,0,0,158,155,1,0,0,0,159,162,1,0,0,0,160,158,
        1,0,0,0,160,161,1,0,0,0,161,163,1,0,0,0,162,160,1,0,0,0,163,164,
        5,11,0,0,164,11,1,0,0,0,165,166,5,13,0,0,166,169,5,52,0,0,167,168,
        5,14,0,0,168,170,3,14,7,0,169,167,1,0,0,0,169,170,1,0,0,0,170,171,
        1,0,0,0,171,172,5,15,0,0,172,173,3,48,24,0,173,177,5,16,0,0,174,
        176,5,60,0,0,175,174,1,0,0,0,176,179,1,0,0,0,177,175,1,0,0,0,177,
        178,1,0,0,0,178,185,1,0,0,0,179,177,1,0,0,0,180,181,3,2,1,0,181,
        182,5,60,0,0,182,184,1,0,0,0,183,180,1,0,0,0,184,187,1,0,0,0,185,
        183,1,0,0,0,185,186,1,0,0,0,186,189,1,0,0,0,187,185,1,0,0,0,188,
        190,3,18,9,0,189,188,1,0,0,0,189,190,1,0,0,0,190,194,1,0,0,0,191,
        193,5,60,0,0,192,191,1,0,0,0,193,196,1,0,0,0,194,195,1,0,0,0,194,
        192,1,0,0,0,195,197,1,0,0,0,196,194,1,0,0,0,197,198,5,17,0,0,198,
        13,1,0,0,0,199,204,3,16,8,0,200,201,5,18,0,0,201,203,3,16,8,0,202,
        200,1,0,0,0,203,206,1,0,0,0,204,202,1,0,0,0,204,205,1,0,0,0,205,
        208,1,0,0,0,206,204,1,0,0,0,207,199,1,0,0,0,207,208,1,0,0,0,208,
        15,1,0,0,0,209,210,5,19,0,0,210,211,3,48,24,0,211,212,5,52,0,0,212,
        17,1,0,0,0,213,214,5,20,0,0,214,215,3,44,22,0,215,19,1,0,0,0,216,
        217,5,19,0,0,217,218,3,48,24,0,218,219,5,52,0,0,219,21,1,0,0,0,220,
        221,5,19,0,0,221,222,3,48,24,0,222,223,5,52,0,0,223,224,5,21,0,0,
        224,225,3,44,22,0,225,23,1,0,0,0,226,229,3,20,10,0,227,229,3,22,
        11,0,228,226,1,0,0,0,228,227,1,0,0,0,229,25,1,0,0,0,230,231,5,22,
        0,0,231,232,3,48,24,0,232,233,5,52,0,0,233,234,5,21,0,0,234,239,
        3,28,14,0,235,236,5,18,0,0,236,238,3,28,14,0,237,235,1,0,0,0,238,
        241,1,0,0,0,239,237,1,0,0,0,239,240,1,0,0,0,240,244,1,0,0,0,241,
        239,1,0,0,0,242,243,5,23,0,0,243,245,5,54,0,0,244,242,1,0,0,0,244,
        245,1,0,0,0,245,27,1,0,0,0,246,247,3,44,22,0,247,29,1,0,0,0,248,
        251,5,52,0,0,249,251,3,32,16,0,250,248,1,0,0,0,250,249,1,0,0,0,251,
        31,1,0,0,0,252,253,5,24,0,0,253,254,3,44,22,0,254,255,5,25,0,0,255,
        256,3,44,22,0,256,33,1,0,0,0,257,258,5,52,0,0,258,259,5,21,0,0,259,
        260,3,44,22,0,260,35,1,0,0,0,261,262,5,26,0,0,262,263,3,44,22,0,
        263,264,5,27,0,0,264,265,3,44,22,0,265,266,5,28,0,0,266,267,3,44,
        22,0,267,37,1,0,0,0,268,269,5,29,0,0,269,270,5,52,0,0,270,271,3,
        40,20,0,271,39,1,0,0,0,272,275,3,24,12,0,273,275,3,44,22,0,274,272,
        1,0,0,0,274,273,1,0,0,0,275,283,1,0,0,0,276,279,5,18,0,0,277,280,
        3,24,12,0,278,280,3,44,22,0,279,277,1,0,0,0,279,278,1,0,0,0,280,
        282,1,0,0,0,281,276,1,0,0,0,282,285,1,0,0,0,283,281,1,0,0,0,283,
        284,1,0,0,0,284,287,1,0,0,0,285,283,1,0,0,0,286,274,1,0,0,0,286,
        287,1,0,0,0,287,41,1,0,0,0,288,289,5,30,0,0,289,290,3,44,22,0,290,
        291,5,27,0,0,291,292,3,48,24,0,292,43,1,0,0,0,293,294,6,22,-1,0,
        294,295,5,57,0,0,295,296,3,44,22,0,296,297,5,58,0,0,297,302,1,0,
        0,0,298,299,7,0,0,0,299,302,3,44,22,5,300,302,3,46,23,0,301,293,
        1,0,0,0,301,298,1,0,0,0,301,300,1,0,0,0,302,323,1,0,0,0,303,304,
        10,8,0,0,304,305,7,1,0,0,305,322,3,44,22,9,306,307,10,7,0,0,307,
        308,7,2,0,0,308,322,3,44,22,8,309,310,10,6,0,0,310,311,7,3,0,0,311,
        322,3,44,22,7,312,313,10,4,0,0,313,314,7,4,0,0,314,322,3,44,22,5,
        315,316,10,3,0,0,316,317,5,45,0,0,317,322,3,44,22,4,318,319,10,2,
        0,0,319,320,5,46,0,0,320,322,3,44,22,3,321,303,1,0,0,0,321,306,1,
        0,0,0,321,309,1,0,0,0,321,312,1,0,0,0,321,315,1,0,0,0,321,318,1,
        0,0,0,322,325,1,0,0,0,323,321,1,0,0,0,323,324,1,0,0,0,324,45,1,0,
        0,0,325,323,1,0,0,0,326,331,5,53,0,0,327,331,5,55,0,0,328,331,5,
        56,0,0,329,331,3,30,15,0,330,326,1,0,0,0,330,327,1,0,0,0,330,328,
        1,0,0,0,330,329,1,0,0,0,331,47,1,0,0,0,332,333,7,5,0,0,333,49,1,
        0,0,0,33,52,55,57,71,77,87,95,107,115,127,135,144,152,160,169,177,
        185,189,194,204,207,228,239,244,250,274,279,283,286,301,321,323,
        330
    ]

class kmmszarpParser ( Parser ):

    grammarFileName = "kmmszarp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'p\\u0119tla'", "'zakres'", "'od'", "'do'", 
                     "'pocz\\u0105tek p\\u0119tli'", "'koniec p\\u0119tli'", 
                     "'podczas'", "'je\\u017Celi'", "'wtedy'", "'pocz\\u0105tek je\\u017Celi'", 
                     "'koniec je\\u017Celi'", "'w przeciwnym wypadku'", 
                     "'czynno\\u015B\\u0107'", "'parametry'", "'zwraca'", 
                     "'pocz\\u0105tek czynno\\u015Bci'", "'koniec czynno\\u015Bci'", 
                     "'i'", "'zmienna'", "'zwr\\u00F3\\u0107'", "'to'", 
                     "'tablica'", "'o d\\u0142ugo\\u015Bci'", "'we\\u017A'", 
                     "'element'", "'w\\u0142\\u00F3\\u017C'", "'na'", "'miejsce'", 
                     "'wywo\\u0142aj'", "'rzu\\u0107'", "'razy'", "'przez'", 
                     "'modu\\u0142'", "'doda\\u0107'", "'odj\\u0105\\u0107'", 
                     "'wi\\u0119ksze ni\\u017C'", "'mniejsze ni\\u017C'", 
                     "'wi\\u0119ksze lub r\\u00F3wne'", "'mniejsze lub r\\u00F3wne'", 
                     "'przemie\\u0144'", "'zaneguj'", "'nie'", "'r\\u00F3wne'", 
                     "'nier\\u00F3wne'", "'oraz'", "'lub'", "'liczba'", 
                     "'napis'", "'prawdziwo\\u015B\\u0107'", "'nico\\u015B\\u0107'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'pocz\\u0105tek nawiasu'", 
                     "'koniec nawiasu'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "EXID", "ID", 
                      "INT", "PINT", "STRING", "BOOL", "LPAR", "RPAR", "WHITESPACE", 
                      "NEWLINE" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopFor = 2
    RULE_loopWhile = 3
    RULE_conditionalStatement = 4
    RULE_conditionalStatementElse = 5
    RULE_functionDefinition = 6
    RULE_parameterList = 7
    RULE_parameter = 8
    RULE_returnStatement = 9
    RULE_pureVariableDeclaration = 10
    RULE_variableDeclarationWithAssignment = 11
    RULE_variableDeclaration = 12
    RULE_arrayDeclaration = 13
    RULE_arrayValue = 14
    RULE_variableReference = 15
    RULE_arrayAccess = 16
    RULE_variableAssignment = 17
    RULE_arrayAssignment = 18
    RULE_functionCall = 19
    RULE_argumentList = 20
    RULE_cast = 21
    RULE_expression = 22
    RULE_primary = 23
    RULE_dtype = 24

    ruleNames =  [ "program", "statement", "loopFor", "loopWhile", "conditionalStatement", 
                   "conditionalStatementElse", "functionDefinition", "parameterList", 
                   "parameter", "returnStatement", "pureVariableDeclaration", 
                   "variableDeclarationWithAssignment", "variableDeclaration", 
                   "arrayDeclaration", "arrayValue", "variableReference", 
                   "arrayAccess", "variableAssignment", "arrayAssignment", 
                   "functionCall", "argumentList", "cast", "expression", 
                   "primary", "dtype" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    EXID=51
    ID=52
    INT=53
    PINT=54
    STRING=55
    BOOL=56
    LPAR=57
    RPAR=58
    WHITESPACE=59
    NEWLINE=60

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = kmmszarpParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 1157425105916666114) != 0):
                self.state = 55
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1, 8, 13, 19, 22, 26, 29, 30, 52]:
                    self.state = 50
                    self.statement()
                    self.state = 52
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                    if la_ == 1:
                        self.state = 51
                        self.match(kmmszarpParser.NEWLINE)


                    pass
                elif token in [60]:
                    self.state = 54
                    self.match(kmmszarpParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopFor(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopForContext,0)


        def loopWhile(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopWhileContext,0)


        def conditionalStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalStatementContext,0)


        def conditionalStatementElse(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalStatementElseContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionDefinitionContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,0)


        def arrayDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayDeclarationContext,0)


        def variableAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableAssignmentContext,0)


        def arrayAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAssignmentContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionCallContext,0)


        def cast(self):
            return self.getTypedRuleContext(kmmszarpParser.CastContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = kmmszarpParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 71
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 60
                self.loopFor()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 61
                self.loopWhile()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 62
                self.conditionalStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 63
                self.conditionalStatementElse()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 64
                self.functionDefinition()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 65
                self.variableDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 66
                self.arrayDeclaration()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 67
                self.variableAssignment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 68
                self.arrayAssignment()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 69
                self.functionCall()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 70
                self.cast()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopForContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def pureVariableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.PureVariableDeclarationContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopFor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopFor" ):
                listener.enterLoopFor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopFor" ):
                listener.exitLoopFor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopFor" ):
                return visitor.visitLoopFor(self)
            else:
                return visitor.visitChildren(self)




    def loopFor(self):

        localctx = kmmszarpParser.LoopForContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopFor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.match(kmmszarpParser.T__0)
            self.state = 74
            self.match(kmmszarpParser.T__1)
            self.state = 77
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.state = 75
                self.pureVariableDeclaration()
                pass
            elif token in [52]:
                self.state = 76
                self.match(kmmszarpParser.ID)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 79
            self.match(kmmszarpParser.T__2)
            self.state = 80
            self.expression(0)
            self.state = 81
            self.match(kmmszarpParser.T__3)
            self.state = 82
            self.expression(0)
            self.state = 83
            self.match(kmmszarpParser.T__4)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 84
                self.match(kmmszarpParser.NEWLINE)
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503601309819138) != 0):
                self.state = 90
                self.statement()
                self.state = 91
                self.match(kmmszarpParser.NEWLINE)
                self.state = 97
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 98
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopWhileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopWhile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopWhile" ):
                listener.enterLoopWhile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopWhile" ):
                listener.exitLoopWhile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopWhile" ):
                return visitor.visitLoopWhile(self)
            else:
                return visitor.visitChildren(self)




    def loopWhile(self):

        localctx = kmmszarpParser.LoopWhileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loopWhile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(kmmszarpParser.T__0)
            self.state = 101
            self.match(kmmszarpParser.T__6)
            self.state = 102
            self.expression(0)
            self.state = 103
            self.match(kmmszarpParser.T__4)
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 104
                self.match(kmmszarpParser.NEWLINE)
                self.state = 109
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503601309819138) != 0):
                self.state = 110
                self.statement()
                self.state = 111
                self.match(kmmszarpParser.NEWLINE)
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 118
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_conditionalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatement" ):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatement" ):
                listener.exitConditionalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionalStatement" ):
                return visitor.visitConditionalStatement(self)
            else:
                return visitor.visitChildren(self)




    def conditionalStatement(self):

        localctx = kmmszarpParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conditionalStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(kmmszarpParser.T__7)
            self.state = 121
            self.expression(0)
            self.state = 122
            self.match(kmmszarpParser.T__8)
            self.state = 123
            self.match(kmmszarpParser.T__9)
            self.state = 127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 124
                self.match(kmmszarpParser.NEWLINE)
                self.state = 129
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503601309819138) != 0):
                self.state = 130
                self.statement()
                self.state = 131
                self.match(kmmszarpParser.NEWLINE)
                self.state = 137
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 138
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementElseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalStatementContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_conditionalStatementElse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatementElse" ):
                listener.enterConditionalStatementElse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatementElse" ):
                listener.exitConditionalStatementElse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionalStatementElse" ):
                return visitor.visitConditionalStatementElse(self)
            else:
                return visitor.visitChildren(self)




    def conditionalStatementElse(self):

        localctx = kmmszarpParser.ConditionalStatementElseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_conditionalStatementElse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.conditionalStatement()
            self.state = 144
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 141
                self.match(kmmszarpParser.NEWLINE)
                self.state = 146
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 147
            self.match(kmmszarpParser.T__11)
            self.state = 148
            self.match(kmmszarpParser.T__9)
            self.state = 152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==60:
                self.state = 149
                self.match(kmmszarpParser.NEWLINE)
                self.state = 154
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503601309819138) != 0):
                self.state = 155
                self.statement()
                self.state = 156
                self.match(kmmszarpParser.NEWLINE)
                self.state = 162
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 163
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(kmmszarpParser.ParameterListContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def returnStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ReturnStatementContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDefinition" ):
                listener.enterFunctionDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDefinition" ):
                listener.exitFunctionDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefinition" ):
                return visitor.visitFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def functionDefinition(self):

        localctx = kmmszarpParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(kmmszarpParser.T__12)
            self.state = 166
            self.match(kmmszarpParser.ID)
            self.state = 169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 167
                self.match(kmmszarpParser.T__13)
                self.state = 168
                self.parameterList()


            self.state = 171
            self.match(kmmszarpParser.T__14)
            self.state = 172
            self.dtype()
            self.state = 173
            self.match(kmmszarpParser.T__15)
            self.state = 177
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 174
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 179
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503601309819138) != 0):
                self.state = 180
                self.statement()
                self.state = 181
                self.match(kmmszarpParser.NEWLINE)
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 188
                self.returnStatement()


            self.state = 194
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 191
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 196
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

            self.state = 197
            self.match(kmmszarpParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ParameterContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ParameterContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = kmmszarpParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 199
                self.parameter()
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 200
                    self.match(kmmszarpParser.T__17)
                    self.state = 201
                    self.parameter()
                    self.state = 206
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = kmmszarpParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(kmmszarpParser.T__18)
            self.state = 210
            self.dtype()
            self.state = 211
            self.match(kmmszarpParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = kmmszarpParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(kmmszarpParser.T__19)
            self.state = 214
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PureVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_pureVariableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPureVariableDeclaration" ):
                listener.enterPureVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPureVariableDeclaration" ):
                listener.exitPureVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPureVariableDeclaration" ):
                return visitor.visitPureVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def pureVariableDeclaration(self):

        localctx = kmmszarpParser.PureVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_pureVariableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(kmmszarpParser.T__18)
            self.state = 217
            self.dtype()
            self.state = 218
            self.match(kmmszarpParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationWithAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableDeclarationWithAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclarationWithAssignment" ):
                listener.enterVariableDeclarationWithAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclarationWithAssignment" ):
                listener.exitVariableDeclarationWithAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclarationWithAssignment" ):
                return visitor.visitVariableDeclarationWithAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclarationWithAssignment(self):

        localctx = kmmszarpParser.VariableDeclarationWithAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_variableDeclarationWithAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self.match(kmmszarpParser.T__18)
            self.state = 221
            self.dtype()
            self.state = 222
            self.match(kmmszarpParser.ID)
            self.state = 223
            self.match(kmmszarpParser.T__20)
            self.state = 224
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pureVariableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.PureVariableDeclarationContext,0)


        def variableDeclarationWithAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationWithAssignmentContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = kmmszarpParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_variableDeclaration)
        try:
            self.state = 228
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 226
                self.pureVariableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 227
                self.variableDeclarationWithAssignment()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ArrayValueContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ArrayValueContext,i)


        def PINT(self):
            return self.getToken(kmmszarpParser.PINT, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayDeclaration" ):
                listener.enterArrayDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayDeclaration" ):
                listener.exitArrayDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayDeclaration" ):
                return visitor.visitArrayDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def arrayDeclaration(self):

        localctx = kmmszarpParser.ArrayDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_arrayDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(kmmszarpParser.T__21)
            self.state = 231
            self.dtype()
            self.state = 232
            self.match(kmmszarpParser.ID)
            self.state = 233
            self.match(kmmszarpParser.T__20)
            self.state = 234
            self.arrayValue()
            self.state = 239
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 235
                self.match(kmmszarpParser.T__17)
                self.state = 236
                self.arrayValue()
                self.state = 241
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 242
                self.match(kmmszarpParser.T__22)
                self.state = 243
                self.match(kmmszarpParser.PINT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValue" ):
                listener.enterArrayValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValue" ):
                listener.exitArrayValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayValue" ):
                return visitor.visitArrayValue(self)
            else:
                return visitor.visitChildren(self)




    def arrayValue(self):

        localctx = kmmszarpParser.ArrayValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_arrayValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayAccess(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAccessContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableReference" ):
                listener.enterVariableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableReference" ):
                listener.exitVariableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableReference" ):
                return visitor.visitVariableReference(self)
            else:
                return visitor.visitChildren(self)




    def variableReference(self):

        localctx = kmmszarpParser.VariableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_variableReference)
        try:
            self.state = 250
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [52]:
                self.enterOuterAlt(localctx, 1)
                self.state = 248
                self.match(kmmszarpParser.ID)
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 249
                self.arrayAccess()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAccess" ):
                listener.enterArrayAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAccess" ):
                listener.exitArrayAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAccess" ):
                return visitor.visitArrayAccess(self)
            else:
                return visitor.visitChildren(self)




    def arrayAccess(self):

        localctx = kmmszarpParser.ArrayAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_arrayAccess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.match(kmmszarpParser.T__23)
            self.state = 253
            self.expression(0)
            self.state = 254
            self.match(kmmszarpParser.T__24)
            self.state = 255
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableAssignment" ):
                listener.enterVariableAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableAssignment" ):
                listener.exitVariableAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableAssignment" ):
                return visitor.visitVariableAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableAssignment(self):

        localctx = kmmszarpParser.VariableAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_variableAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(kmmszarpParser.ID)
            self.state = 258
            self.match(kmmszarpParser.T__20)
            self.state = 259
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAssignment" ):
                listener.enterArrayAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAssignment" ):
                listener.exitArrayAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAssignment" ):
                return visitor.visitArrayAssignment(self)
            else:
                return visitor.visitChildren(self)




    def arrayAssignment(self):

        localctx = kmmszarpParser.ArrayAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_arrayAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.match(kmmszarpParser.T__25)
            self.state = 262
            self.expression(0)
            self.state = 263
            self.match(kmmszarpParser.T__26)
            self.state = 264
            self.expression(0)
            self.state = 265
            self.match(kmmszarpParser.T__27)
            self.state = 266
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def argumentList(self):
            return self.getTypedRuleContext(kmmszarpParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = kmmszarpParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_functionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.match(kmmszarpParser.T__28)
            self.state = 269
            self.match(kmmszarpParser.ID)
            self.state = 270
            self.argumentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = kmmszarpParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.state = 274
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 272
                    self.variableDeclaration()
                    pass
                elif token in [24, 40, 41, 42, 52, 53, 55, 56, 57]:
                    self.state = 273
                    self.expression(0)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 283
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 276
                    self.match(kmmszarpParser.T__17)
                    self.state = 279
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [19]:
                        self.state = 277
                        self.variableDeclaration()
                        pass
                    elif token in [24, 40, 41, 42, 52, 53, 55, 56, 57]:
                        self.state = 278
                        self.expression(0)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 285
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def dtype(self):
            return self.getTypedRuleContext(kmmszarpParser.DtypeContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kmmszarpParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(kmmszarpParser.T__29)
            self.state = 289
            self.expression(0)
            self.state = 290
            self.match(kmmszarpParser.T__26)
            self.state = 291
            self.dtype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ParenthesizedExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAR(self):
            return self.getToken(kmmszarpParser.LPAR, 0)
        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)

        def RPAR(self):
            return self.getToken(kmmszarpParser.RPAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)


    class LogicOrContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.or_ = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)


    class MultiplicationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplication" ):
                listener.enterMultiplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplication" ):
                listener.exitMultiplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplication" ):
                return visitor.visitMultiplication(self)
            else:
                return visitor.visitChildren(self)


    class AdditionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddition" ):
                listener.enterAddition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddition" ):
                listener.exitAddition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddition" ):
                return visitor.visitAddition(self)
            else:
                return visitor.visitChildren(self)


    class NegationContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNegation" ):
                listener.enterNegation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNegation" ):
                listener.exitNegation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNegation" ):
                return visitor.visitNegation(self)
            else:
                return visitor.visitChildren(self)


    class PrimaryExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primary(self):
            return self.getTypedRuleContext(kmmszarpParser.PrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpression" ):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpression" ):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpression" ):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)


    class ComparisonContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)


    class EqualityContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.eq = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquality" ):
                listener.enterEquality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquality" ):
                listener.exitEquality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquality" ):
                return visitor.visitEquality(self)
            else:
                return visitor.visitChildren(self)


    class LogicAndContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.ExpressionContext
            super().__init__(parser)
            self.and_ = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = kmmszarpParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 44
        self.enterRecursionRule(localctx, 44, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [57]:
                localctx = kmmszarpParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 294
                self.match(kmmszarpParser.LPAR)
                self.state = 295
                self.expression(0)
                self.state = 296
                self.match(kmmszarpParser.RPAR)
                pass
            elif token in [40, 41, 42]:
                localctx = kmmszarpParser.NegationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 298
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 299
                self.expression(5)
                pass
            elif token in [24, 52, 53, 55, 56]:
                localctx = kmmszarpParser.PrimaryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 300
                self.primary()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 323
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 321
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
                    if la_ == 1:
                        localctx = kmmszarpParser.MultiplicationContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 303
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 304
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 15032385536) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 305
                        self.expression(9)
                        pass

                    elif la_ == 2:
                        localctx = kmmszarpParser.AdditionContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 306
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 307
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==34 or _la==35):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 308
                        self.expression(8)
                        pass

                    elif la_ == 3:
                        localctx = kmmszarpParser.ComparisonContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 309
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 310
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1030792151040) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 311
                        self.expression(7)
                        pass

                    elif la_ == 4:
                        localctx = kmmszarpParser.EqualityContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 312
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 313
                        localctx.eq = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==43 or _la==44):
                            localctx.eq = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 314
                        self.expression(5)
                        pass

                    elif la_ == 5:
                        localctx = kmmszarpParser.LogicAndContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 315
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 316
                        localctx.and_ = self.match(kmmszarpParser.T__44)
                        self.state = 317
                        self.expression(4)
                        pass

                    elif la_ == 6:
                        localctx = kmmszarpParser.LogicOrContext(self, kmmszarpParser.ExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 318
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 319
                        localctx.or_ = self.match(kmmszarpParser.T__45)
                        self.state = 320
                        self.expression(3)
                        pass

             
                self.state = 325
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_primary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StringLiteralContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(kmmszarpParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class BoolLiteralContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(kmmszarpParser.BOOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolLiteral" ):
                listener.enterBoolLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolLiteral" ):
                listener.exitBoolLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolLiteral" ):
                return visitor.visitBoolLiteral(self)
            else:
                return visitor.visitChildren(self)


    class IntLiteralContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(kmmszarpParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntLiteral" ):
                listener.enterIntLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntLiteral" ):
                listener.exitIntLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntLiteral" ):
                return visitor.visitIntLiteral(self)
            else:
                return visitor.visitChildren(self)


    class VariableReferencePrimaryContext(PrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a kmmszarpParser.PrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def variableReference(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableReferenceContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableReferencePrimary" ):
                listener.enterVariableReferencePrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableReferencePrimary" ):
                listener.exitVariableReferencePrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableReferencePrimary" ):
                return visitor.visitVariableReferencePrimary(self)
            else:
                return visitor.visitChildren(self)



    def primary(self):

        localctx = kmmszarpParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_primary)
        try:
            self.state = 330
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [53]:
                localctx = kmmszarpParser.IntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 326
                self.match(kmmszarpParser.INT)
                pass
            elif token in [55]:
                localctx = kmmszarpParser.StringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 327
                self.match(kmmszarpParser.STRING)
                pass
            elif token in [56]:
                localctx = kmmszarpParser.BoolLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 328
                self.match(kmmszarpParser.BOOL)
                pass
            elif token in [24, 52]:
                localctx = kmmszarpParser.VariableReferencePrimaryContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 329
                self.variableReference()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_dtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDtype" ):
                listener.enterDtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDtype" ):
                listener.exitDtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDtype" ):
                return visitor.visitDtype(self)
            else:
                return visitor.visitChildren(self)




    def dtype(self):

        localctx = kmmszarpParser.DtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_dtype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2111062325329920) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[22] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         




