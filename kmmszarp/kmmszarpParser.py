# Generated from ./kmmszarp.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,55,363,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,1,0,1,0,3,0,59,8,0,1,0,5,0,62,8,0,10,0,12,0,65,9,0,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,76,8,1,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,5,2,87,8,2,10,2,12,2,90,9,2,1,2,1,2,1,2,5,2,95,8,2,
        10,2,12,2,98,9,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,5,3,107,8,3,10,3,12,
        3,110,9,3,1,3,1,3,1,3,5,3,115,8,3,10,3,12,3,118,9,3,1,3,1,3,1,4,
        1,4,1,4,1,4,1,4,5,4,127,8,4,10,4,12,4,130,9,4,1,4,1,4,1,4,5,4,135,
        8,4,10,4,12,4,138,9,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,5,5,147,8,5,10,
        5,12,5,150,9,5,1,5,1,5,1,5,5,5,155,8,5,10,5,12,5,158,9,5,1,5,1,5,
        5,5,162,8,5,10,5,12,5,165,9,5,1,5,1,5,1,5,5,5,170,8,5,10,5,12,5,
        173,9,5,1,5,1,5,1,5,5,5,178,8,5,10,5,12,5,181,9,5,1,5,1,5,1,6,1,
        6,1,6,1,6,3,6,189,8,6,1,6,1,6,1,6,1,6,5,6,195,8,6,10,6,12,6,198,
        9,6,1,6,1,6,1,6,5,6,203,8,6,10,6,12,6,206,9,6,1,6,3,6,209,8,6,1,
        6,5,6,212,8,6,10,6,12,6,215,9,6,1,6,1,6,1,7,1,7,1,7,5,7,222,8,7,
        10,7,12,7,225,9,7,3,7,227,8,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,10,1,
        10,1,10,1,10,1,10,3,10,241,8,10,1,11,1,11,1,11,1,11,1,11,1,11,1,
        11,5,11,250,8,11,10,11,12,11,253,9,11,1,11,1,11,3,11,257,8,11,1,
        12,1,12,1,13,1,13,3,13,263,8,13,1,14,1,14,1,14,1,14,1,14,1,15,1,
        15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,1,17,1,17,1,
        17,1,18,1,18,3,18,287,8,18,1,18,1,18,1,18,3,18,292,8,18,5,18,294,
        8,18,10,18,12,18,297,9,18,3,18,299,8,18,1,19,1,19,1,20,1,20,1,20,
        5,20,306,8,20,10,20,12,20,309,9,20,1,21,1,21,1,21,5,21,314,8,21,
        10,21,12,21,317,9,21,1,22,1,22,1,22,5,22,322,8,22,10,22,12,22,325,
        9,22,1,23,1,23,1,23,5,23,330,8,23,10,23,12,23,333,9,23,1,24,1,24,
        1,24,5,24,338,8,24,10,24,12,24,341,9,24,1,25,1,25,1,25,5,25,346,
        8,25,10,25,12,25,349,9,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,
        3,26,359,8,26,1,27,1,27,1,27,1,213,0,28,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,0,5,1,0,32,
        33,1,0,34,37,1,0,38,39,1,0,40,42,1,0,43,46,381,0,63,1,0,0,0,2,75,
        1,0,0,0,4,77,1,0,0,0,6,101,1,0,0,0,8,121,1,0,0,0,10,141,1,0,0,0,
        12,184,1,0,0,0,14,226,1,0,0,0,16,228,1,0,0,0,18,232,1,0,0,0,20,235,
        1,0,0,0,22,242,1,0,0,0,24,258,1,0,0,0,26,262,1,0,0,0,28,264,1,0,
        0,0,30,269,1,0,0,0,32,273,1,0,0,0,34,280,1,0,0,0,36,298,1,0,0,0,
        38,300,1,0,0,0,40,302,1,0,0,0,42,310,1,0,0,0,44,318,1,0,0,0,46,326,
        1,0,0,0,48,334,1,0,0,0,50,342,1,0,0,0,52,358,1,0,0,0,54,360,1,0,
        0,0,56,58,3,2,1,0,57,59,5,54,0,0,58,57,1,0,0,0,58,59,1,0,0,0,59,
        62,1,0,0,0,60,62,5,54,0,0,61,56,1,0,0,0,61,60,1,0,0,0,62,65,1,0,
        0,0,63,61,1,0,0,0,63,64,1,0,0,0,64,1,1,0,0,0,65,63,1,0,0,0,66,76,
        3,4,2,0,67,76,3,6,3,0,68,76,3,8,4,0,69,76,3,12,6,0,70,76,3,20,10,
        0,71,76,3,22,11,0,72,76,3,30,15,0,73,76,3,32,16,0,74,76,3,34,17,
        0,75,66,1,0,0,0,75,67,1,0,0,0,75,68,1,0,0,0,75,69,1,0,0,0,75,70,
        1,0,0,0,75,71,1,0,0,0,75,72,1,0,0,0,75,73,1,0,0,0,75,74,1,0,0,0,
        76,3,1,0,0,0,77,78,5,1,0,0,78,79,5,2,0,0,79,80,3,20,10,0,80,81,5,
        3,0,0,81,82,3,38,19,0,82,83,5,4,0,0,83,84,3,38,19,0,84,88,5,5,0,
        0,85,87,5,54,0,0,86,85,1,0,0,0,87,90,1,0,0,0,88,86,1,0,0,0,88,89,
        1,0,0,0,89,96,1,0,0,0,90,88,1,0,0,0,91,92,3,2,1,0,92,93,5,54,0,0,
        93,95,1,0,0,0,94,91,1,0,0,0,95,98,1,0,0,0,96,94,1,0,0,0,96,97,1,
        0,0,0,97,99,1,0,0,0,98,96,1,0,0,0,99,100,5,6,0,0,100,5,1,0,0,0,101,
        102,5,1,0,0,102,103,5,7,0,0,103,104,3,38,19,0,104,108,5,5,0,0,105,
        107,5,54,0,0,106,105,1,0,0,0,107,110,1,0,0,0,108,106,1,0,0,0,108,
        109,1,0,0,0,109,116,1,0,0,0,110,108,1,0,0,0,111,112,3,2,1,0,112,
        113,5,54,0,0,113,115,1,0,0,0,114,111,1,0,0,0,115,118,1,0,0,0,116,
        114,1,0,0,0,116,117,1,0,0,0,117,119,1,0,0,0,118,116,1,0,0,0,119,
        120,5,6,0,0,120,7,1,0,0,0,121,122,5,8,0,0,122,123,3,38,19,0,123,
        124,5,9,0,0,124,128,5,10,0,0,125,127,5,54,0,0,126,125,1,0,0,0,127,
        130,1,0,0,0,128,126,1,0,0,0,128,129,1,0,0,0,129,136,1,0,0,0,130,
        128,1,0,0,0,131,132,3,2,1,0,132,133,5,54,0,0,133,135,1,0,0,0,134,
        131,1,0,0,0,135,138,1,0,0,0,136,134,1,0,0,0,136,137,1,0,0,0,137,
        139,1,0,0,0,138,136,1,0,0,0,139,140,5,11,0,0,140,9,1,0,0,0,141,142,
        5,8,0,0,142,143,3,38,19,0,143,144,5,9,0,0,144,148,5,10,0,0,145,147,
        5,54,0,0,146,145,1,0,0,0,147,150,1,0,0,0,148,146,1,0,0,0,148,149,
        1,0,0,0,149,156,1,0,0,0,150,148,1,0,0,0,151,152,3,2,1,0,152,153,
        5,54,0,0,153,155,1,0,0,0,154,151,1,0,0,0,155,158,1,0,0,0,156,154,
        1,0,0,0,156,157,1,0,0,0,157,159,1,0,0,0,158,156,1,0,0,0,159,163,
        5,11,0,0,160,162,5,54,0,0,161,160,1,0,0,0,162,165,1,0,0,0,163,161,
        1,0,0,0,163,164,1,0,0,0,164,166,1,0,0,0,165,163,1,0,0,0,166,167,
        5,12,0,0,167,171,5,10,0,0,168,170,5,54,0,0,169,168,1,0,0,0,170,173,
        1,0,0,0,171,169,1,0,0,0,171,172,1,0,0,0,172,179,1,0,0,0,173,171,
        1,0,0,0,174,175,3,2,1,0,175,176,5,54,0,0,176,178,1,0,0,0,177,174,
        1,0,0,0,178,181,1,0,0,0,179,177,1,0,0,0,179,180,1,0,0,0,180,182,
        1,0,0,0,181,179,1,0,0,0,182,183,5,11,0,0,183,11,1,0,0,0,184,185,
        5,13,0,0,185,188,5,47,0,0,186,187,5,14,0,0,187,189,3,14,7,0,188,
        186,1,0,0,0,188,189,1,0,0,0,189,190,1,0,0,0,190,191,5,15,0,0,191,
        192,3,54,27,0,192,196,5,16,0,0,193,195,5,54,0,0,194,193,1,0,0,0,
        195,198,1,0,0,0,196,194,1,0,0,0,196,197,1,0,0,0,197,204,1,0,0,0,
        198,196,1,0,0,0,199,200,3,2,1,0,200,201,5,54,0,0,201,203,1,0,0,0,
        202,199,1,0,0,0,203,206,1,0,0,0,204,202,1,0,0,0,204,205,1,0,0,0,
        205,208,1,0,0,0,206,204,1,0,0,0,207,209,3,18,9,0,208,207,1,0,0,0,
        208,209,1,0,0,0,209,213,1,0,0,0,210,212,5,54,0,0,211,210,1,0,0,0,
        212,215,1,0,0,0,213,214,1,0,0,0,213,211,1,0,0,0,214,216,1,0,0,0,
        215,213,1,0,0,0,216,217,5,17,0,0,217,13,1,0,0,0,218,223,3,16,8,0,
        219,220,5,18,0,0,220,222,3,16,8,0,221,219,1,0,0,0,222,225,1,0,0,
        0,223,221,1,0,0,0,223,224,1,0,0,0,224,227,1,0,0,0,225,223,1,0,0,
        0,226,218,1,0,0,0,226,227,1,0,0,0,227,15,1,0,0,0,228,229,5,19,0,
        0,229,230,3,54,27,0,230,231,5,47,0,0,231,17,1,0,0,0,232,233,5,20,
        0,0,233,234,3,38,19,0,234,19,1,0,0,0,235,236,5,19,0,0,236,237,3,
        54,27,0,237,240,5,47,0,0,238,239,5,21,0,0,239,241,3,38,19,0,240,
        238,1,0,0,0,240,241,1,0,0,0,241,21,1,0,0,0,242,243,5,22,0,0,243,
        244,3,54,27,0,244,245,5,47,0,0,245,246,5,21,0,0,246,251,3,24,12,
        0,247,248,5,18,0,0,248,250,3,24,12,0,249,247,1,0,0,0,250,253,1,0,
        0,0,251,249,1,0,0,0,251,252,1,0,0,0,252,256,1,0,0,0,253,251,1,0,
        0,0,254,255,5,23,0,0,255,257,5,49,0,0,256,254,1,0,0,0,256,257,1,
        0,0,0,257,23,1,0,0,0,258,259,3,38,19,0,259,25,1,0,0,0,260,263,5,
        47,0,0,261,263,3,28,14,0,262,260,1,0,0,0,262,261,1,0,0,0,263,27,
        1,0,0,0,264,265,5,24,0,0,265,266,3,38,19,0,266,267,5,25,0,0,267,
        268,3,38,19,0,268,29,1,0,0,0,269,270,5,47,0,0,270,271,5,21,0,0,271,
        272,3,38,19,0,272,31,1,0,0,0,273,274,5,26,0,0,274,275,3,38,19,0,
        275,276,5,27,0,0,276,277,3,38,19,0,277,278,5,28,0,0,278,279,3,38,
        19,0,279,33,1,0,0,0,280,281,5,29,0,0,281,282,5,47,0,0,282,283,3,
        36,18,0,283,35,1,0,0,0,284,287,3,20,10,0,285,287,3,38,19,0,286,284,
        1,0,0,0,286,285,1,0,0,0,287,295,1,0,0,0,288,291,5,18,0,0,289,292,
        3,20,10,0,290,292,3,38,19,0,291,289,1,0,0,0,291,290,1,0,0,0,292,
        294,1,0,0,0,293,288,1,0,0,0,294,297,1,0,0,0,295,293,1,0,0,0,295,
        296,1,0,0,0,296,299,1,0,0,0,297,295,1,0,0,0,298,286,1,0,0,0,298,
        299,1,0,0,0,299,37,1,0,0,0,300,301,3,40,20,0,301,39,1,0,0,0,302,
        307,3,42,21,0,303,304,5,30,0,0,304,306,3,42,21,0,305,303,1,0,0,0,
        306,309,1,0,0,0,307,305,1,0,0,0,307,308,1,0,0,0,308,41,1,0,0,0,309,
        307,1,0,0,0,310,315,3,44,22,0,311,312,5,31,0,0,312,314,3,44,22,0,
        313,311,1,0,0,0,314,317,1,0,0,0,315,313,1,0,0,0,315,316,1,0,0,0,
        316,43,1,0,0,0,317,315,1,0,0,0,318,323,3,46,23,0,319,320,7,0,0,0,
        320,322,3,46,23,0,321,319,1,0,0,0,322,325,1,0,0,0,323,321,1,0,0,
        0,323,324,1,0,0,0,324,45,1,0,0,0,325,323,1,0,0,0,326,331,3,48,24,
        0,327,328,7,1,0,0,328,330,3,48,24,0,329,327,1,0,0,0,330,333,1,0,
        0,0,331,329,1,0,0,0,331,332,1,0,0,0,332,47,1,0,0,0,333,331,1,0,0,
        0,334,339,3,50,25,0,335,336,7,2,0,0,336,338,3,50,25,0,337,335,1,
        0,0,0,338,341,1,0,0,0,339,337,1,0,0,0,339,340,1,0,0,0,340,49,1,0,
        0,0,341,339,1,0,0,0,342,347,3,52,26,0,343,344,7,3,0,0,344,346,3,
        52,26,0,345,343,1,0,0,0,346,349,1,0,0,0,347,345,1,0,0,0,347,348,
        1,0,0,0,348,51,1,0,0,0,349,347,1,0,0,0,350,359,5,48,0,0,351,359,
        5,50,0,0,352,359,5,51,0,0,353,359,3,26,13,0,354,355,5,52,0,0,355,
        356,3,38,19,0,356,357,5,53,0,0,357,359,1,0,0,0,358,350,1,0,0,0,358,
        351,1,0,0,0,358,352,1,0,0,0,358,353,1,0,0,0,358,354,1,0,0,0,359,
        53,1,0,0,0,360,361,7,4,0,0,361,55,1,0,0,0,37,58,61,63,75,88,96,108,
        116,128,136,148,156,163,171,179,188,196,204,208,213,223,226,240,
        251,256,262,286,291,295,298,307,315,323,331,339,347,358
    ]

class kmmszarpParser ( Parser ):

    grammarFileName = "kmmszarp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'p\\u0119tla'", "'zakres'", "'od'", "'do'", 
                     "'pocz\\u0105tek p\\u0119tli'", "'koniec p\\u0119tli'", 
                     "'podczas'", "'je\\u017Celi'", "'wtedy'", "'pocz\\u0105tek je\\u017Celi'", 
                     "'koniec je\\u017Celi'", "'w przeciwnym wypadku'", 
                     "'czynno\\u015B\\u0107'", "'parametry'", "'zwraca'", 
                     "'pocz\\u0105tek czynno\\u015Bci'", "'koniec czynno\\u015Bci'", 
                     "'i'", "'zmienna'", "'zwr\\u00F3\\u0107'", "'to'", 
                     "'tablica'", "'o d\\u0142ugo\\u015Bci'", "'we\\u017A'", 
                     "'element'", "'w\\u0142\\u00F3\\u017C'", "'na'", "'miejsce'", 
                     "'wywo\\u0142aj'", "'lub'", "'oraz'", "'r\\u00F3wne'", 
                     "'nier\\u00F3wne'", "'wi\\u0119ksze ni\\u017C'", "'mniejsze ni\\u017C'", 
                     "'wi\\u0119ksze lub r\\u00F3wne'", "'mniejsze lub r\\u00F3wne'", 
                     "'doda\\u0107'", "'odj\\u0105\\u0107'", "'razy'", "'przez'", 
                     "'modu\\u0142'", "'liczba'", "'napis'", "'prawdziwo\\u015B\\u0107'", 
                     "'nico\\u015B\\u0107'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'pocz\\u0105tek nawiasu'", 
                     "'koniec nawiasu'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "ID", "INT", 
                      "PINT", "STRING", "BOOL", "LPAR", "RPAR", "NEWLINE", 
                      "WHITESPACE" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopFor = 2
    RULE_loopWhile = 3
    RULE_conditional = 4
    RULE_ifelse = 5
    RULE_functionDefinition = 6
    RULE_parameterList = 7
    RULE_parameter = 8
    RULE_returnStatement = 9
    RULE_variableDeclaration = 10
    RULE_arrayDeclaration = 11
    RULE_arrayValue = 12
    RULE_variableReference = 13
    RULE_arrayAccess = 14
    RULE_variableAssignment = 15
    RULE_arrayAssignment = 16
    RULE_functionCall = 17
    RULE_argumentList = 18
    RULE_expression = 19
    RULE_logicOr = 20
    RULE_logicAnd = 21
    RULE_equality = 22
    RULE_comparison = 23
    RULE_addition = 24
    RULE_multiplication = 25
    RULE_primary = 26
    RULE_type = 27

    ruleNames =  [ "program", "statement", "loopFor", "loopWhile", "conditional", 
                   "ifelse", "functionDefinition", "parameterList", "parameter", 
                   "returnStatement", "variableDeclaration", "arrayDeclaration", 
                   "arrayValue", "variableReference", "arrayAccess", "variableAssignment", 
                   "arrayAssignment", "functionCall", "argumentList", "expression", 
                   "logicOr", "logicAnd", "equality", "comparison", "addition", 
                   "multiplication", "primary", "type" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    ID=47
    INT=48
    PINT=49
    STRING=50
    BOOL=51
    LPAR=52
    RPAR=53
    NEWLINE=54
    WHITESPACE=55

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = kmmszarpParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 18155136606544130) != 0):
                self.state = 61
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1, 8, 13, 19, 22, 26, 29, 47]:
                    self.state = 56
                    self.statement()
                    self.state = 58
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                    if la_ == 1:
                        self.state = 57
                        self.match(kmmszarpParser.NEWLINE)


                    pass
                elif token in [54]:
                    self.state = 60
                    self.match(kmmszarpParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopFor(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopForContext,0)


        def loopWhile(self):
            return self.getTypedRuleContext(kmmszarpParser.LoopWhileContext,0)


        def conditional(self):
            return self.getTypedRuleContext(kmmszarpParser.ConditionalContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionDefinitionContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,0)


        def arrayDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayDeclarationContext,0)


        def variableAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableAssignmentContext,0)


        def arrayAssignment(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAssignmentContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(kmmszarpParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = kmmszarpParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 75
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 66
                self.loopFor()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 67
                self.loopWhile()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 68
                self.conditional()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 69
                self.functionDefinition()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 70
                self.variableDeclaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 71
                self.arrayDeclaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 72
                self.variableAssignment()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 73
                self.arrayAssignment()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 74
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopForContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopFor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopFor" ):
                listener.enterLoopFor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopFor" ):
                listener.exitLoopFor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopFor" ):
                return visitor.visitLoopFor(self)
            else:
                return visitor.visitChildren(self)




    def loopFor(self):

        localctx = kmmszarpParser.LoopForContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopFor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.match(kmmszarpParser.T__0)
            self.state = 78
            self.match(kmmszarpParser.T__1)
            self.state = 79
            self.variableDeclaration()
            self.state = 80
            self.match(kmmszarpParser.T__2)
            self.state = 81
            self.expression()
            self.state = 82
            self.match(kmmszarpParser.T__3)
            self.state = 83
            self.expression()
            self.state = 84
            self.match(kmmszarpParser.T__4)
            self.state = 88
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==54:
                self.state = 85
                self.match(kmmszarpParser.NEWLINE)
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 96
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 140738097062146) != 0):
                self.state = 91
                self.statement()
                self.state = 92
                self.match(kmmszarpParser.NEWLINE)
                self.state = 98
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 99
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopWhileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_loopWhile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopWhile" ):
                listener.enterLoopWhile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopWhile" ):
                listener.exitLoopWhile(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopWhile" ):
                return visitor.visitLoopWhile(self)
            else:
                return visitor.visitChildren(self)




    def loopWhile(self):

        localctx = kmmszarpParser.LoopWhileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_loopWhile)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(kmmszarpParser.T__0)
            self.state = 102
            self.match(kmmszarpParser.T__6)
            self.state = 103
            self.expression()
            self.state = 104
            self.match(kmmszarpParser.T__4)
            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==54:
                self.state = 105
                self.match(kmmszarpParser.NEWLINE)
                self.state = 110
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 116
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 140738097062146) != 0):
                self.state = 111
                self.statement()
                self.state = 112
                self.match(kmmszarpParser.NEWLINE)
                self.state = 118
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 119
            self.match(kmmszarpParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional" ):
                listener.enterConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional" ):
                listener.exitConditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditional" ):
                return visitor.visitConditional(self)
            else:
                return visitor.visitChildren(self)




    def conditional(self):

        localctx = kmmszarpParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_conditional)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(kmmszarpParser.T__7)
            self.state = 122
            self.expression()
            self.state = 123
            self.match(kmmszarpParser.T__8)
            self.state = 124
            self.match(kmmszarpParser.T__9)
            self.state = 128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==54:
                self.state = 125
                self.match(kmmszarpParser.NEWLINE)
                self.state = 130
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 140738097062146) != 0):
                self.state = 131
                self.statement()
                self.state = 132
                self.match(kmmszarpParser.NEWLINE)
                self.state = 138
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 139
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfelseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_ifelse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfelse" ):
                listener.enterIfelse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfelse" ):
                listener.exitIfelse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfelse" ):
                return visitor.visitIfelse(self)
            else:
                return visitor.visitChildren(self)




    def ifelse(self):

        localctx = kmmszarpParser.IfelseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ifelse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(kmmszarpParser.T__7)
            self.state = 142
            self.expression()
            self.state = 143
            self.match(kmmszarpParser.T__8)
            self.state = 144
            self.match(kmmszarpParser.T__9)
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==54:
                self.state = 145
                self.match(kmmszarpParser.NEWLINE)
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 140738097062146) != 0):
                self.state = 151
                self.statement()
                self.state = 152
                self.match(kmmszarpParser.NEWLINE)
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 159
            self.match(kmmszarpParser.T__10)
            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==54:
                self.state = 160
                self.match(kmmszarpParser.NEWLINE)
                self.state = 165
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 166
            self.match(kmmszarpParser.T__11)
            self.state = 167
            self.match(kmmszarpParser.T__9)
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==54:
                self.state = 168
                self.match(kmmszarpParser.NEWLINE)
                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 140738097062146) != 0):
                self.state = 174
                self.statement()
                self.state = 175
                self.match(kmmszarpParser.NEWLINE)
                self.state = 181
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 182
            self.match(kmmszarpParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def parameterList(self):
            return self.getTypedRuleContext(kmmszarpParser.ParameterListContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(kmmszarpParser.NEWLINE)
            else:
                return self.getToken(kmmszarpParser.NEWLINE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.StatementContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.StatementContext,i)


        def returnStatement(self):
            return self.getTypedRuleContext(kmmszarpParser.ReturnStatementContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDefinition" ):
                listener.enterFunctionDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDefinition" ):
                listener.exitFunctionDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefinition" ):
                return visitor.visitFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def functionDefinition(self):

        localctx = kmmszarpParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.match(kmmszarpParser.T__12)
            self.state = 185
            self.match(kmmszarpParser.ID)
            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 186
                self.match(kmmszarpParser.T__13)
                self.state = 187
                self.parameterList()


            self.state = 190
            self.match(kmmszarpParser.T__14)
            self.state = 191
            self.type_()
            self.state = 192
            self.match(kmmszarpParser.T__15)
            self.state = 196
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 193
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 198
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

            self.state = 204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 140738097062146) != 0):
                self.state = 199
                self.statement()
                self.state = 200
                self.match(kmmszarpParser.NEWLINE)
                self.state = 206
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 207
                self.returnStatement()


            self.state = 213
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 210
                    self.match(kmmszarpParser.NEWLINE) 
                self.state = 215
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

            self.state = 216
            self.match(kmmszarpParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ParameterContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ParameterContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameterList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterList" ):
                listener.enterParameterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterList" ):
                listener.exitParameterList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = kmmszarpParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 218
                self.parameter()
                self.state = 223
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 219
                    self.match(kmmszarpParser.T__17)
                    self.state = 220
                    self.parameter()
                    self.state = 225
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = kmmszarpParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.match(kmmszarpParser.T__18)
            self.state = 229
            self.type_()
            self.state = 230
            self.match(kmmszarpParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = kmmszarpParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(kmmszarpParser.T__19)
            self.state = 233
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = kmmszarpParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.match(kmmszarpParser.T__18)
            self.state = 236
            self.type_()
            self.state = 237
            self.match(kmmszarpParser.ID)
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 238
                self.match(kmmszarpParser.T__20)
                self.state = 239
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(kmmszarpParser.TypeContext,0)


        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ArrayValueContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ArrayValueContext,i)


        def PINT(self):
            return self.getToken(kmmszarpParser.PINT, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayDeclaration" ):
                listener.enterArrayDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayDeclaration" ):
                listener.exitArrayDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayDeclaration" ):
                return visitor.visitArrayDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def arrayDeclaration(self):

        localctx = kmmszarpParser.ArrayDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_arrayDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(kmmszarpParser.T__21)
            self.state = 243
            self.type_()
            self.state = 244
            self.match(kmmszarpParser.ID)
            self.state = 245
            self.match(kmmszarpParser.T__20)
            self.state = 246
            self.arrayValue()
            self.state = 251
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 247
                self.match(kmmszarpParser.T__17)
                self.state = 248
                self.arrayValue()
                self.state = 253
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 254
                self.match(kmmszarpParser.T__22)
                self.state = 255
                self.match(kmmszarpParser.PINT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValue" ):
                listener.enterArrayValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValue" ):
                listener.exitArrayValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayValue" ):
                return visitor.visitArrayValue(self)
            else:
                return visitor.visitChildren(self)




    def arrayValue(self):

        localctx = kmmszarpParser.ArrayValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arrayValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def arrayAccess(self):
            return self.getTypedRuleContext(kmmszarpParser.ArrayAccessContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableReference

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableReference" ):
                listener.enterVariableReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableReference" ):
                listener.exitVariableReference(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableReference" ):
                return visitor.visitVariableReference(self)
            else:
                return visitor.visitChildren(self)




    def variableReference(self):

        localctx = kmmszarpParser.VariableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_variableReference)
        try:
            self.state = 262
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [47]:
                self.enterOuterAlt(localctx, 1)
                self.state = 260
                self.match(kmmszarpParser.ID)
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 261
                self.arrayAccess()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAccess" ):
                listener.enterArrayAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAccess" ):
                listener.exitArrayAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAccess" ):
                return visitor.visitArrayAccess(self)
            else:
                return visitor.visitChildren(self)




    def arrayAccess(self):

        localctx = kmmszarpParser.ArrayAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_arrayAccess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(kmmszarpParser.T__23)
            self.state = 265
            self.expression()
            self.state = 266
            self.match(kmmszarpParser.T__24)
            self.state = 267
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_variableAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableAssignment" ):
                listener.enterVariableAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableAssignment" ):
                listener.exitVariableAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableAssignment" ):
                return visitor.visitVariableAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableAssignment(self):

        localctx = kmmszarpParser.VariableAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_variableAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.match(kmmszarpParser.ID)
            self.state = 270
            self.match(kmmszarpParser.T__20)
            self.state = 271
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_arrayAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAssignment" ):
                listener.enterArrayAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAssignment" ):
                listener.exitArrayAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAssignment" ):
                return visitor.visitArrayAssignment(self)
            else:
                return visitor.visitChildren(self)




    def arrayAssignment(self):

        localctx = kmmszarpParser.ArrayAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_arrayAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 273
            self.match(kmmszarpParser.T__25)
            self.state = 274
            self.expression()
            self.state = 275
            self.match(kmmszarpParser.T__26)
            self.state = 276
            self.expression()
            self.state = 277
            self.match(kmmszarpParser.T__27)
            self.state = 278
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(kmmszarpParser.ID, 0)

        def argumentList(self):
            return self.getTypedRuleContext(kmmszarpParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = kmmszarpParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_functionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(kmmszarpParser.T__28)
            self.state = 281
            self.match(kmmszarpParser.ID)
            self.state = 282
            self.argumentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.VariableDeclarationContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = kmmszarpParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.state = 286
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 284
                    self.variableDeclaration()
                    pass
                elif token in [24, 47, 48, 50, 51, 52]:
                    self.state = 285
                    self.expression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 295
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==18:
                    self.state = 288
                    self.match(kmmszarpParser.T__17)
                    self.state = 291
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [19]:
                        self.state = 289
                        self.variableDeclaration()
                        pass
                    elif token in [24, 47, 48, 50, 51, 52]:
                        self.state = 290
                        self.expression()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 297
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicOr(self):
            return self.getTypedRuleContext(kmmszarpParser.LogicOrContext,0)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = kmmszarpParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.logicOr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicOrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicAnd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.LogicAndContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.LogicAndContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_logicOr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)




    def logicOr(self):

        localctx = kmmszarpParser.LogicOrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_logicOr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.logicAnd()
            self.state = 307
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,30,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 303
                    self.match(kmmszarpParser.T__29)
                    self.state = 304
                    self.logicAnd() 
                self.state = 309
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicAndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equality(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.EqualityContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.EqualityContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_logicAnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)




    def logicAnd(self):

        localctx = kmmszarpParser.LogicAndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_logicAnd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.equality()
            self.state = 315
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 311
                    self.match(kmmszarpParser.T__30)
                    self.state = 312
                    self.equality() 
                self.state = 317
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.ComparisonContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_equality

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquality" ):
                listener.enterEquality(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquality" ):
                listener.exitEquality(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEquality" ):
                return visitor.visitEquality(self)
            else:
                return visitor.visitChildren(self)




    def equality(self):

        localctx = kmmszarpParser.EqualityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_equality)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.comparison()
            self.state = 323
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 319
                    _la = self._input.LA(1)
                    if not(_la==32 or _la==33):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 320
                    self.comparison() 
                self.state = 325
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.AdditionContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.AdditionContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kmmszarpParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 326
            self.addition()
            self.state = 331
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 327
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 257698037760) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 328
                    self.addition() 
                self.state = 333
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplication(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.MultiplicationContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.MultiplicationContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_addition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddition" ):
                listener.enterAddition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddition" ):
                listener.exitAddition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddition" ):
                return visitor.visitAddition(self)
            else:
                return visitor.visitChildren(self)




    def addition(self):

        localctx = kmmszarpParser.AdditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_addition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.multiplication()
            self.state = 339
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,34,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 335
                    _la = self._input.LA(1)
                    if not(_la==38 or _la==39):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 336
                    self.multiplication() 
                self.state = 341
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kmmszarpParser.PrimaryContext)
            else:
                return self.getTypedRuleContext(kmmszarpParser.PrimaryContext,i)


        def getRuleIndex(self):
            return kmmszarpParser.RULE_multiplication

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplication" ):
                listener.enterMultiplication(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplication" ):
                listener.exitMultiplication(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplication" ):
                return visitor.visitMultiplication(self)
            else:
                return visitor.visitChildren(self)




    def multiplication(self):

        localctx = kmmszarpParser.MultiplicationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_multiplication)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.primary()
            self.state = 347
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 343
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 344
                    self.primary() 
                self.state = 349
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(kmmszarpParser.INT, 0)

        def STRING(self):
            return self.getToken(kmmszarpParser.STRING, 0)

        def BOOL(self):
            return self.getToken(kmmszarpParser.BOOL, 0)

        def variableReference(self):
            return self.getTypedRuleContext(kmmszarpParser.VariableReferenceContext,0)


        def LPAR(self):
            return self.getToken(kmmszarpParser.LPAR, 0)

        def expression(self):
            return self.getTypedRuleContext(kmmszarpParser.ExpressionContext,0)


        def RPAR(self):
            return self.getToken(kmmszarpParser.RPAR, 0)

        def getRuleIndex(self):
            return kmmszarpParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimary" ):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)




    def primary(self):

        localctx = kmmszarpParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_primary)
        try:
            self.state = 358
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 350
                self.match(kmmszarpParser.INT)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 2)
                self.state = 351
                self.match(kmmszarpParser.STRING)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 352
                self.match(kmmszarpParser.BOOL)
                pass
            elif token in [24, 47]:
                self.enterOuterAlt(localctx, 4)
                self.state = 353
                self.variableReference()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 5)
                self.state = 354
                self.match(kmmszarpParser.LPAR)
                self.state = 355
                self.expression()
                self.state = 356
                self.match(kmmszarpParser.RPAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kmmszarpParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)




    def type_(self):

        localctx = kmmszarpParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 131941395333120) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





